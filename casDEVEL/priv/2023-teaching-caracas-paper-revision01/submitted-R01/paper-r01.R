# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit paper-r01.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
options(prompt = 'R> ', continue = '+ ')
knitr::opts_chunk$set(echo = TRUE, cache = !TRUE, message = FALSE,
                      fig.height = 3, fig.width = 5, prompt = TRUE)
library(caracas)
options(caracas.print.method = "prettyascii")
options(caracas.prompt = "[c]: ")
options("digits" = 3)

library(knitr)
library(kableExtra)


## ---- echo=FALSE--------------------------------------------------------------
inline_code <- function(x) {
  x
}

texdot <- function(x) {
  #tex(x, zero_as_dot = TRUE, matstr = c("matrix", "r"))
  tex(x, zero_as_dot = TRUE)
}


## -----------------------------------------------------------------------------
M0 <- toeplitz(c("a", "b"))  ## Character matrix
M  <- as_sym(M0)             ## as_sym() converts to a caracas symbol
v  <- vector_sym(2, "v")     ## vector_sym creates symbolic vector
y  <- M %*% v
Minv <- inv(M) %>% simplify()
v2 <- Minv %*% y  |> simplify()


## -----------------------------------------------------------------------------
M


## -----------------------------------------------------------------------------
Minv_fact <- as_factor_list(1 / det(M), simplify(det(M) * Minv))


## -----------------------------------------------------------------------------
as_expr(M)
def_sym(a) ## This creates the symbol 'a'
a
M2 <- subs(M, "b", "a^2")
M3 <- subs(M2, a, 2)


## -----------------------------------------------------------------------------
def_sym(x)  
p <- 1 - x^2 + x^3 + x^4/4 - 3 * x^5 / 5 + x^6 / 6


## -----------------------------------------------------------------------------
g <- der(p, x) 
g2 <- factor_(g)
h <- der2(p, x)


## -----------------------------------------------------------------------------
sol <- solve_sys(lhs = g, rhs = 0, vars = x)
sol
sol_expr <- sapply(sol, sapply, as_expr) |> unname()
sol_expr


## ---- eval=T------------------------------------------------------------------
p_fn <- as_func(p)
p_fn
g_fn <- as_func(g)
h_fn <- as_func(h)
h_fn(sol_expr)


## ----calculus, echo = TRUE, fig.cap="Left: A polynomium. Center: The gradient. Right: The Hessian.", echo=FALSE, fig.height=1.3, fig.width=5, layout = "l-body-outset"----
dat <- data.frame(x=seq(-1.2,2.2,0.1))
dat$p <- p_fn(dat$x)
dat$g <- g_fn(dat$x)
dat$h <- h_fn(dat$x)
stationary_points <- c(-1, 0, 1, 2)
library(ggplot2)
theme_set(theme_bw())
p1 <- dat |> ggplot(aes(x, p)) + geom_line() + geom_vline(xintercept = stationary_points, col='red', linetype=4)
p2 <- dat |> ggplot(aes(x, g)) + geom_line() + geom_vline(xintercept = stationary_points, col='red', linetype=4)
p3 <- dat |> ggplot(aes(x, h)) + geom_line() + geom_vline(xintercept = stationary_points, col='red', linetype=4)
cowplot::plot_grid(p1, p2, p3, nrow=1)


## -----------------------------------------------------------------------------
x <- as_sym("x")
half_circle_ <- sqrt(1-x^2)
ad <- int(half_circle_, "x")          ## Anti derivative
area <- int(half_circle_, "x", -1, 1) ## Definite integral


## -----------------------------------------------------------------------------
def_sym(x, n)
y <- (1 + x/n)^n
l <- lim(y, n, Inf, doit = FALSE)
l_2 <- doit(l)


## ----anova-two-way-table, echo=F----------------------------------------------
tt <- structure(c("$y_{11}$", "$y_{21}$", "$y_{12}$", "$y_{22}$"), 
                dim = c(2L, 2L), 
                dimnames = list(NULL, NULL))
tt %>%
  kable(col.names = NULL, escape = FALSE, caption = "Two-by-two layout of data.") %>%
  kable_styling(bootstrap_options = "bordered",
                latex_options = "hold_position",
                full_width = FALSE) %>%
  column_spec(column = 1,
              border_left = TRUE) %>%
  column_spec(column = 2,
              border_right = TRUE) 


## -----------------------------------------------------------------------------
nr <- 2
nc <- 2
y  <- as_sym(c("y_11", "y_21", "y_12", "y_22"))
dat <- expand.grid(r = factor(1:nr), s = factor(1:nc))
X <- model.matrix(~ r + s, data = dat) |> as_sym()
b <- vector_sym(ncol(X), "b")
mu <- X %*% b


## -----------------------------------------------------------------------------
XtX <- t(X) %*% X
XtXinv <- inv(XtX)
Xty <- t(X) %*% y
b_hat <- XtXinv %*% Xty


## -----------------------------------------------------------------------------
data(budworm, package = "doBy")
bud <- subset(budworm, sex == "male")
bud


## ----budworm, echo = TRUE, fig.cap="Insecticide mortality of the moth tobacco budworm.", echo=FALSE, fig.height=2.0, fig.width=5, layout = "l-body-outset"----
library(ggplot2)
theme_set(theme_bw())
p1<-bud  %>% ggplot(aes(x=dose, y=log((ndead+0.5) / (ntotal - ndead + 0.5)))) +
    geom_point() + geom_line() + labs(y = "Empirical logits")
p2<-bud  %>% ggplot(aes(x=log2(dose), y=log((ndead + 0.5) / (ntotal - ndead + 0.5)))) +
    geom_point() + geom_line() + labs(y = "Empirical logits")
cowplot::plot_grid(p1, p2, nrow=1)


## -----------------------------------------------------------------------------
DM <- cbind(model.matrix(~log2(dose), data=bud),
            bud[, c("ndead", "ntotal")])  |> as.matrix()
DM |> head(3)


## -----------------------------------------------------------------------------
def_sym(s, p)
sol_ <- solve_sys(lhs = log(p / (1 - p)), rhs = s, vars = p)
p_s <- sol_[[1]]$p


## -----------------------------------------------------------------------------
def_sym(y, n)
b  <- vector_sym(2, "b")
x  <- vector_sym(2, "x")
logLp_ <- y * log(p) + (n - y) * log(1 - p) ## logL as fn of p
s_b <- sum(x * b)                           ## s as fn of b
p_b <- subs(p_s, s, s_b)                    ## p as fn of b
logLb_ <- subs(logLp_, p, p_b)              ## logL as fn of b
Sb_ <- score(logLb_, b) |> simplify()
Hb_ <- hessian(logLb_, b) |> simplify()


## -----------------------------------------------------------------------------
nms <- c("x1", "x2", "y", "n")
DM_lst <- doBy::split_byrow(DM)
logLb_lst <- lapply(DM_lst, function(vls) {
    subs(logLb_, nms, vls)
})


## -----------------------------------------------------------------------------
logLb_tot <- Reduce(`+`, logLb_lst) 
logLb_fn  <- as_func(logLb_tot, vec_arg = TRUE)
opt <- optim(c(b1=0, b2=0), logLb_fn, control = list(fnscale = -1), hessian = TRUE)
opt$par


## ---- eval=T------------------------------------------------------------------
m <- glm(cbind(ndead, ntotal - ndead) ~ log2(dose), family=binomial(), data=bud)
m |> coef()


## -----------------------------------------------------------------------------
N <- 6; q <- 2
X <- matrix_sym(N, q, "x")
n <- vector_sym(N, "n")
y <- vector_sym(N, "y")
p <- vector_sym(N, "p")
s <- vector_sym(N, "s")
b <- vector_sym(q, "b")


## -----------------------------------------------------------------------------
logLp <- sum(y * log(p) + (n - y) * log(1 - p)) ## logL as fn of p
p_s <- exp(s) / (exp(s) + 1)                    ## p as fn of s
s_b <- X %*% b                                  ## s as fn of b
p_b <- subs(p_s, s, s_b)                        ## p as fn of b
logLb_ <- subs(logLp, p, p_b)                   ## logL as fn of b


## ---- eval=T------------------------------------------------------------------
logLb <- subs(logLb_, cbind(X, y, n), DM)
logLb_fn <- as_func(logLb, vec_arg = TRUE)
opt <- optim(c(b1=0, b2=0), logLb_fn, control = list(fnscale = -1), hessian = TRUE)
opt$par


## -----------------------------------------------------------------------------
def_sym(u, r2, s2, lambda_)
y  <- as_sym(c("y_11", "y_21", "y_12", "y_22"))
p  <- as_sym(c("u", "u*r2", "u*s2", "u*r2*s2"))
logL <- sum(y * log(p))
Lag  <- -logL + lambda_ * (sum(p) - 1) 
vars <- list(u, r2, s2, lambda_)
gLag <- der(Lag, vars)
sol  <- solve_sys(gLag, vars)
print(sol, method = "ascii")
sol <- sol[[1]]


## -----------------------------------------------------------------------------
p11 <- sol$u
p21 <- sol$u * sol$r2
p12 <- sol$u * sol$s2
p22 <- sol$u * sol$r2 * sol$s2
p.hat <- matrix_(c(p11, p21, p12, p22), nrow = 2)


## -----------------------------------------------------------------------------
H <- hessian(logL, list(u, r2, s2)) |> simplify()


## ---- echo=FALSE, eval=FALSE--------------------------------------------------
#> rv <- vector_sym(2, "r")
#> sv <- vector_sym(2, "s")
#> m <- rv %*% t(sv)
#> p <- u*m |> vec()
#> l <- sum(n * log(p))


## ---- echo=FALSE, eval=FALSE--------------------------------------------------
#> def_sym(a, a1, a2, u, r1, r2, s1, s2)
#> p <- as_sym(c("u*r1*s1", "u*r2*s1", "u*r1*s2", "u*r2*s2"))
#> l  <- sum(y * log(p))
#> L  <- -l + a * (sum(p) - 1) + a1 * (r1 - 1) + a2 * (s1 - 1)
#> vars <- list(u, r2, s2, a, a1, a2)
#> gL <- der(L, vars)
#> sol <- solve_sys(gL, vars)
#> sol <- sol[[1]]


## ---- echo=F------------------------------------------------------------------
e <- as_sym(paste0("e", 0:3))
x <- as_sym(paste0("x", 0:3))
u <- vector_sym(3, "u")
y <- vector_sym(3, "y")
eu <- rbind(e, u)
xy <- rbind(x, y)


## ---- echo=FALSE--------------------------------------------------------------
L <- diff_mat(4, "-a")


## ---- echo=F------------------------------------------------------------------
n <- 4
def_sym(a)
x <- vector_sym(n, "x")
e <- vector_sym(n, "e")
L <- diff_mat(n, "-a")
L[1, 1] <- sqrt(1-a^2)


## -----------------------------------------------------------------------------
def_sym(a, v)
n <- 4
L <- diff_mat(n, "-a")
L[1, 1] <- sqrt(1-a^2)
Linv <- inv(L)
K <- crossprod_(L) / v
V <- tcrossprod_(Linv) * v


## ---- echo=F, results="asis"--------------------------------------------------
cat(
  "\\begin{align} 
    L^{-1} &= ", texdot(Linv), " , \\\\ 
    K &= ", texdot(mat_factor_div(K, v)), " , \\\\ 
    V &= ", texdot(mat_factor_mult(V, v)), "  .
  \\end{align}", sep = "")


## -----------------------------------------------------------------------------
x <- vector_sym(n, "x")
logL <- log(det(K)) - sum(K * (x %*% t(x))) |> simplify()


## -----------------------------------------------------------------------------
xt <- c(0.1, -0.9, 0.4, 0.0)
logL. <- subs(logL, x, xt) 


## -----------------------------------------------------------------------------
logL_wrap <- as_func(logL., vec_arg = TRUE)
eps <- 0.01
par <- optim(c(a=0, v=1), logL_wrap, 
             lower=c(-(1-eps), eps), upper=c((1-eps), 10),
             method="L-BFGS-B", control=list(fnscale=-1))$par
par


## ---- eval=FALSE--------------------------------------------------------------
#> arima(xt, order = c(1, 0, 0), include.mean = FALSE, method = "ML")


## ----echo=FALSE---------------------------------------------------------------
n <- 3


## ----echo=FALSE---------------------------------------------------------------
R <- as_sym(toeplitz(c(1, rep("r", n-1))))
# FIXME: SH? mikl: EXERCISE!
#R <- as_sym(toeplitz(rep(paste0("r^", 0:3))))


## -----------------------------------------------------------------------------
def_sym(v, r, n, j, i) 
var_sum <- v * (n + 2 * sum_(sum_(r, j, i + 1, n), i, 1, n - 1)) |> simplify()
var_avg <- var_sum / n^2


## -----------------------------------------------------------------------------
l_1 <- lim(var_avg, n, Inf)         ## when sample size n goes to infinity
l_2 <- lim(var_avg, r, 0, dir='+')  ## when correlation r goes to zero
l_3 <- lim(var_avg, r, 1, dir='-')  ## when correlation r goes to one


## -----------------------------------------------------------------------------
def_sym(k_n)
sol <- solve_sys(var_avg - v / k_n, k_n)
k_n <- sol[[1]]$k_n
l_k <- lim(k_n, n, Inf)


## -----------------------------------------------------------------------------
dat <- expand.grid(r=c(.1, .2, .5), n=c(10, 50))
k_fn <- as_func(k_n)
dat$k_n <- k_fn(r=dat$r, n=dat$n)
dat$l_k <- 1 / dat$r
dat


## ----echo=FALSE---------------------------------------------------------------
Rex5 <- as_sym(toeplitz(c(1, "r", rep(0, 3-2))))


## -----------------------------------------------------------------------------
library(reticulate)
s <- import("sympy") 
py_run_string("from sympy import *")
py_run_string("x = symbols('x')")
p <- py_eval("1 - x**2 + x**3 + x**4/4 - 3 * x**5 / 5 + x**6 / 6")
p$evalf(subs = list(x = 1))
sol <- s$solve(s$diff(p, "x"), "x")


## ---- eval=FALSE--------------------------------------------------------------
#> s$latex(p)


## ---- eval=FALSE--------------------------------------------------------------
#> def_sym(x)
#> p <- 1 - x^2 + x^3 + x^4/4 - 3 * x^5 / 5 + x^6 / 6
#> sol <- solve_sys(der(p, x), x)


## -----------------------------------------------------------------------------
library(reticulate)
s <- import("sympy") 
py_run_string("from sympy import *")
py_run_string("a = symbols('a')")
X_str <- "Matrix([[a, 1],[a, 1],[1, 0]])"
X <- py_eval(X_str, convert = FALSE) 
(X$T * X)$inv()


## ---- eval=FALSE--------------------------------------------------------------
#> X <- matrix_(c("a", "1", "a", "1", "1", "0"), nrow = 3, byrow=TRUE)
#> (t(X) %*% X) |> inv()


## -----------------------------------------------------------------------------
sympy <- get_sympy()
sympy$diff("sin(x * y)", "x", "y")


## -----------------------------------------------------------------------------
def_sym(x, y)
f <- sin(x * y) 
der(f, list(x, y))


## -----------------------------------------------------------------------------
der_diff <- function(expr, ...){
	 sympy_func(expr, "diff", ...)
}
der_diff(sin(x * y), x, y)


## ---- eval=FALSE--------------------------------------------------------------
#> sympy$diff("sin(x * y)", "x", 100L)
#> der_diff(sin(x * y), x, 100L)

