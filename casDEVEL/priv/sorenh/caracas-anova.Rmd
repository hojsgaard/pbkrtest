---
title: "caracas-anova"
author: "Søren Højsgaard"
date: "3/31/2020"
output: html_document
---

```{r setup, include=FALSE}
library(magrittr)
library(Matrix)
knitr::opts_chunk$set(echo = TRUE)
```

The matrix algebra approach to linear normal models is convenient but the matrix algebra also darkens the computations. 

Example: One-way anova:

```{r}
g <- 1:3
s <- 2
f <- factor(rep(g, each=s))

## Here we would like a symbolic y
y <- rep(1:s, length(g)) * rep(g, each=s)
## For latter use
tapply(y, f, mean)
## The model matrix
X <- model.matrix(~f)  
X
```

```{r}
## Not all that intersting:
solve(t(X) %*% X)
## Just sums, but studens don't necessarily realise that
t(X) %*% y 
## Can it be unfolded what this really is symbolically?
bhat <- solve(t(X) %*% X) %*% t(X) %*% y
bhat
```

```{r}
## The projection matrix
P <- X %*% solve(t(X) %*% X) %*% t(X) %>% zapsmall
P
## Would look nice symbolically
P %*% y
```

```{r}
Id <- diag(1, nrow=nrow(P))
## RSS - residual sum of squares; would look good symbolically
t(y) %*% (Id - P) %*% y
## Alternative formula; maybe easier - probably not:
W <- y %*% t(y) ## Symmetric
(Id - P) %*% W %>% diag %>% sum
((Id - P) * W) %>% sum
```

```{r}
## Find F-statistic
```


```{r}
## Can play with other contrasts,
X2 <- model.matrix(~0+f)
X2
```

```{r}
## Change of basis-matrix; can sympy do so more elegantly?
S <- cbind(solve(t(X2) %*% X2, t(X2) %*% X[,1]),
          solve(t(X2) %*% X2, t(X2) %*% X[,2]),
          solve(t(X2) %*% X2, t(X2) %*% X[,3]))
S
all(X2 %*% S == X)
## What is the connection between bhat in the two bases?
```







