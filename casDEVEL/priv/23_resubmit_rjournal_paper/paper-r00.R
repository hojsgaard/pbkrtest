# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit paper-r00.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------------------------------------------------------------------------------
options(prompt = 'R> ', continue = '+ ')
knitr::opts_chunk$set(echo = TRUE, cache = !TRUE, message = FALSE,
                      fig.height = 3, fig.width = 5, prompt = TRUE)
library(caracas)
options(caracas.print.method = "prettyascii")
options(caracas.prompt = "[c]: ")
options("digits" = 3)

library(knitr)
library(kableExtra)


## ---- echo=FALSE--------------------------------------------------------------------------------------------------------------------------------------
inline_code <- function(x) {
  x
}

texdot <- function(x) {
  #tex(x, zero_as_dot = TRUE, matstr = c("matrix", "r"))
  tex(x, zero_as_dot = TRUE)
}


## -----------------------------------------------------------------------------------------------------------------------------------------------------
M0 <- toeplitz(c("a", "b")) ## Character matrix
M <- as_sym(M0)                ## as_sym() converts to a caracas symbol
Minv <- inv(M) %>% simplify()


## -----------------------------------------------------------------------------------------------------------------------------------------------------
M


## -----------------------------------------------------------------------------------------------------------------------------------------------------
Minv_fact <- as_factor_list(1 / factor_(det(M)), simplify(Minv * det(M)))


## -----------------------------------------------------------------------------------------------------------------------------------------------------
as_expr(M)
def_sym(a) ## FIXME: Should this be necessary
M2 <- subs(M, "b", "a^2")
M3 <- subs(M2, a, 2)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
v <- vector_sym(2, "v")
Mv <- M %*% v


## -----------------------------------------------------------------------------------------------------------------------------------------------------
library(caracas)
def_sym(x) ## Declares 'x' as a symbol
p <- 1 - x^2 + x^3 + x^4/4 - 3 * x^5 / 5 + x^6 / 6


## -----------------------------------------------------------------------------------------------------------------------------------------------------
x$pyobj
p$pyobj


## -----------------------------------------------------------------------------------------------------------------------------------------------------
grad <- der(p, x) 
grad2 <- factor_(grad)
hess <- der2(p, x)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
sol <- solve_sys(lhs = grad, rhs=0, vars = x) 
sol_expr <- sapply(sol, sapply, as_expr) |> unname()
sol_expr


## ---- eval=T------------------------------------------------------------------------------------------------------------------------------------------
p_fn <- as_func(p)
p_fn
grad_fn <- as_func(grad)
hess_fn <- as_func(hess)
hess_fn(sol_expr)


## ----calculus, echo = TRUE, fig.cap="Left: A polynomium. Center: The gradient. Right: The Hessian.", echo=FALSE, fig.height=1.3, fig.width=5, layout = "l-body-outset"----
dat <- data.frame(x=seq(-1.2,2.2,0.1))
dat$p <- p_fn(dat$x)
dat$g <- grad_fn(dat$x)
dat$h <- hess_fn(dat$x)
stationary_points <- c(-1, 0, 1, 2)
library(ggplot2)
theme_set(theme_bw())
p1 <- dat |> ggplot(aes(x, p)) + geom_line() + geom_vline(xintercept = stationary_points, col='red')
p2 <- dat |> ggplot(aes(x, g)) + geom_line() + geom_vline(xintercept = stationary_points, col='red')
p3 <- dat |> ggplot(aes(x, h)) + geom_line() + geom_vline(xintercept = stationary_points, col='red')
cowplot::plot_grid(p1, p2, p3, nrow=1)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
x <- as_sym("x")
half_circle_ <- sqrt(1-x^2)
## Anti derivative:
ad <- int(half_circle_, "x")
## Definite integral:
di <- int(half_circle_, "x", -1, 1)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
def_sym(x, n)
y <- (1 + x/n)^n
l <- lim(y, n, Inf, doit = FALSE)
l2 <- doit(l)


## ----anova-two-way-table, echo=F----------------------------------------------------------------------------------------------------------------------
tt <- structure(c("$y_{11}$", "$y_{12}$", "$y_{21}$", "$y_{22}$"), 
                dim = c(2L, 2L), 
                dimnames = list(NULL, NULL))
tt %>%
  kable(col.names = NULL, escape = FALSE, caption = "Two-by-two layout of data.") %>%
  kable_styling(bootstrap_options = "bordered",
                latex_options = "hold_position",
                full_width = FALSE) %>%
  column_spec(column = 1,
              border_left = TRUE) %>%
  column_spec(column = 2,
              border_right = TRUE) 


## -----------------------------------------------------------------------------------------------------------------------------------------------------
nr <- 2
nc <- 2
y <- matrix_sym(nr, nc, "y")
dim(y) <- c(nr * nc, 1)
y
dat <- expand.grid(r=factor(1:nr), s=factor(1:nc))
X <- model.matrix(~ r + s, data=dat) |> as_sym()
b <- vector_sym(ncol(X), "b")
mu <- X %*% b


## -----------------------------------------------------------------------------------------------------------------------------------------------------
XtX <- t(X) %*% X
XtXinv <- inv(XtX)
Xty <- t(X) %*% y
b_hat <- XtXinv %*% Xty


## -----------------------------------------------------------------------------------------------------------------------------------------------------
data(budworm, package = "doBy")
bud <- subset(budworm, sex == "male")
bud


## ----budworm, echo = TRUE, fig.cap="Insecticide mortality of the moth tobacco budworm.", echo=FALSE, fig.height=2.0, fig.width=5, layout = "l-body-outset"----
library(ggplot2)
theme_set(theme_bw())
p1<-bud  %>% ggplot(aes(x=dose, y=log((ndead+0.5) / (ntotal - ndead + 0.5)))) +
    geom_point() + geom_line() + labs(y = "Empirical logits")
p2<-bud  %>% ggplot(aes(x=log2(dose), y=log((ndead + 0.5) / (ntotal - ndead + 0.5)))) +
    geom_point() + geom_line() + labs(y = "Empirical logits")
cowplot::plot_grid(p1, p2, nrow=1)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
def_sym(s, p)
sol_ <- solve_sys(lhs = log(p / (1 - p)), rhs = s, vars = p)
sol_[[1]]$p


## -----------------------------------------------------------------------------------------------------------------------------------------------------
def_sym(y, n, p, x, s, b)
logLp_ <- y * log(p) + (n - y) * log(1 - p)
p_ <- exp(s) / (exp(s) + 1)
logLs_ <- subs(logLp_, p, p_)
s_ <- sum(x * b)
logLb_ <- subs(logLs_, s, s_)
logLb_


## -----------------------------------------------------------------------------------------------------------------------------------------------------
Sb_ <- score(logLb_, b) |> simplify()
Hb_ <- hessian(logLb_, b) |> simplify()
Sb_
Hb_


## -----------------------------------------------------------------------------------------------------------------------------------------------------
b <- vector_sym(2, "b")
x <- vector_sym(2, "x")
s_ <- sum(x * b)
logLb_ <- subs(logLs_, s, s_)
Sb_ <- score(logLb_, b) |> simplify()


## -----------------------------------------------------------------------------------------------------------------------------------------------------
nms <- c("x1", "x2", "y", "n")
vls <- c(1, 2, 9, 20)
logLb. <- subs(logLb_, nms, vls)
Sb. <- subs(Sb_, nms, vls)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
Sb_list <- lapply(seq_len(nrow(bud)), function(r){
  vls <- c(1, log2(bud$dose[r]), bud$ndead[r], bud$ntotal[r])
  subs(Sb_, nms, vls) 
})
Sb_total <- Reduce(`+`, Sb_list)


## ---- eval=FALSE--------------------------------------------------------------------------------------------------------------------------------------
#> subs(Sb_total, b, c(1, 2))
#> subs(Sb_total, b, c(1, 2)) |> as_expr()


## -----------------------------------------------------------------------------------------------------------------------------------------------------
logLb_list <- lapply(seq_len(nrow(bud)), function(r){
  vls <- c(1, log2(bud$dose[r]), bud$ndead[r], bud$ntotal[r])
  subs(logLb_, nms, vls) 
})
logLb_total <- Reduce(`+`, logLb_list)
logLb_total_func <- as_func(logLb_total, vec_arg = TRUE)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
X. <- as_sym(cbind(1, log2(bud$dose)))
n. <- as_sym(bud$ntotal)
y. <- as_sym(bud$ndead)
N <- nrow(X.)
q <- ncol(X.)
X <- matrix_sym(N, q, "x")
n <- vector_sym(N, "n")
y <- vector_sym(N, "y")
p <- vector_sym(N, "p")
s <- vector_sym(N, "s")
b <- vector_sym(q, "b")


## ---- eval=!FALSE-------------------------------------------------------------------------------------------------------------------------------------
## log-likelihood as function of p
logLp  <- sum(y * log(p) + (n-y) * log(1-p))
## log-likelihood as function of s
p_ <- exp(s) / (exp(s) + 1)
logLs <- subs(logLp, p, p_)
## linear predictor as function of regression coefficients:
s_  <- X %*% b
## log-Likelihood as function of regression coefficients:
logLb <- subs(logLs, s, s_)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
logLb <- subs(logLb, cbind(n, y, X), cbind(n., y., X.))


## ---- eval=FALSE--------------------------------------------------------------------------------------------------------------------------------------
#> logLb_func <- as_func(logLb, vec_arg = TRUE)
#> optim(c(0, 0), logLb_func, control = list(fnscale = -1), hessian = TRUE)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
y_ <- c("y_11", "y_21", "y_12", "y_22")
y  <- as_sym(y_)
def_sym(u, r2, s2, lambda_)
p <- as_sym(c("u", "u*r2", "u*s2", "u*r2*s2"))
logL  <- sum(y * log(p))
Lag  <- -logL + lambda_ * (sum(p) - 1) 
vars <- list(u, r2, s2, lambda_)
gLag <- der(Lag, vars)
sol <- solve_sys(gLag, vars)
print(sol, method = "ascii")
sol <- sol[[1]]


## -----------------------------------------------------------------------------------------------------------------------------------------------------
p11 <- sol$u
p21 <- sol$u * sol$r2
p12 <- sol$u * sol$s2
p22 <- sol$u * sol$r2 * sol$s2
p.hat <- matrix_(c(p11, p21, p12, p22), nrow = 2)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
H <- hessian(logL, list(u, r2, s2)) |> simplify()


## ---- echo=FALSE, eval=FALSE--------------------------------------------------------------------------------------------------------------------------
#> rv <- vector_sym(2, "r")
#> sv <- vector_sym(2, "s")
#> m <- rv %*% t(sv)
#> p <- u*m |> vec()
#> l <- sum(n * log(p))


## ---- echo=FALSE, eval=FALSE--------------------------------------------------------------------------------------------------------------------------
#> def_sym(a, a1, a2, u, r1, r2, s1, s2)
#> p <- as_sym(c("u*r1*s1", "u*r2*s1", "u*r1*s2", "u*r2*s2"))
#> l  <- sum(y * log(p))
#> L  <- -l + a * (sum(p) - 1) + a1 * (r1 - 1) + a2 * (s1 - 1)
#> vars <- list(u, r2, s2, a, a1, a2)
#> gL <- der(L, vars)
#> sol <- solve_sys(gL, vars)
#> sol <- sol[[1]]


## ---- echo=F------------------------------------------------------------------------------------------------------------------------------------------
e <- as_sym(paste0("e", 0:3))
x <- as_sym(paste0("x", 0:3))
u <- vector_sym(3, "u")
y <- vector_sym(3, "y")
eu <- rbind(e, u)
xy <- rbind(x, y)


## ---- echo=FALSE--------------------------------------------------------------------------------------------------------------------------------------
L <- diff_mat(4, "-a")


## ---- echo=F------------------------------------------------------------------------------------------------------------------------------------------
n <- 4
def_sym(a)
x <- vector_sym(n, "x")
e <- vector_sym(n, "e")
L <- diff_mat(n, "-a")
L[1, 1] <- sqrt(1-a^2)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
n <- 4
L <- diff_mat(n, "-a")
def_sym(a)
L[1, 1] <- sqrt(1-a^2)
def_sym(v)
Linv <- inv(L)
K <- crossprod_(L) / v
V <- tcrossprod_(Linv) * v


## ---- echo=F, results="asis"--------------------------------------------------------------------------------------------------------------------------
cat(
  "\\begin{align} 
    L^{-1} &= ", texdot(Linv), " , \\\\ 
    K &= ", texdot(mat_factor_div(K, v)), " , \\\\ 
    V &= ", texdot(mat_factor_mult(V, v)), "  .
  \\end{align}", sep = "")


## -----------------------------------------------------------------------------------------------------------------------------------------------------
x <- vector_sym(n, "x")
logL <- log(det(K)) - sum(K * (x %*% t(x))) %>% simplify()


## -----------------------------------------------------------------------------------------------------------------------------------------------------
xt <- c(0.1, -0.9, 0.4, .0)
logL. <- subs(logL, x, xt) 


## -----------------------------------------------------------------------------------------------------------------------------------------------------
logL_wrap <- as_func(logL., vec_arg = TRUE)
eps <- 0.01
par <- optim(c(a=0, v=1), logL_wrap, 
             lower=c(-(1-eps), eps), upper=c((1-eps), 10),
             method="L-BFGS-B", control=list(fnscale=-1))$par
par


## ---- eval=FALSE--------------------------------------------------------------------------------------------------------------------------------------
#> arima(xt, order = c(1, 0, 0), include.mean = FALSE, method = "ML")


## ----echo=FALSE---------------------------------------------------------------------------------------------------------------------------------------
n <- 3


## ----echo=FALSE---------------------------------------------------------------------------------------------------------------------------------------
R <- as_sym(toeplitz(c(1, rep("r", n-1))))
# FIXME: SH? mikl: EXERCISE!
#R <- as_sym(toeplitz(rep(paste0("r^", 0:3))))


## -----------------------------------------------------------------------------------------------------------------------------------------------------
def_sym(v, r, n, j, i) 
var_sum <- v*(n + 2*sum_(sum_(r, j, i+1, n), i, 1, n-1)) |> simplify()
var_avg <- var_sum / n^2


## -----------------------------------------------------------------------------------------------------------------------------------------------------
l_1 <- lim(var_avg, n, Inf)         ## when sample size n goes to infinity
l_2 <- lim(var_avg, r, 0, dir='+')  ## when correlation r goes to zero
l_3 <- lim(var_avg, r, 1, dir='-')  ## when correlation r goes to one


## -----------------------------------------------------------------------------------------------------------------------------------------------------
def_sym(k)
k <- solve_sys(var_avg - v / k, k)[[1]]$k
l_k <- lim(k, n, Inf)


## -----------------------------------------------------------------------------------------------------------------------------------------------------
dat <- expand.grid(r=c(.1, .2, .5), n=c(10, 50))
k_fun <- as_func(k)
dat$k <- k_fun(r=dat$r, n=dat$n)
dat$ri <- 1/dat$r
dat


## ----echo=FALSE---------------------------------------------------------------------------------------------------------------------------------------
Rex5 <- as_sym(toeplitz(c(1, "r", rep(0, 4-2))))


## ----eval=F-------------------------------------------------------------------------------------------------------------------------------------------
#> r <- reticulate::import("sympy")
#> sss <- "Matrix([[a, a], [0, a]])"
#> s2 <- reticulate::py_eval(sss, convert = FALSE)
#> s2
#> s2$inv()

