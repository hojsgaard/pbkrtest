\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{hyperref,a4,color,boxedminipage,Sweave}
%\VignetteIndexEntry{Introduction to Ryacas}
%\VignettePackage{Ryacas}
%\VignetteDepends{XML}

\usepackage{textcomp}

% Definitions
\newcommand{\slan}{{\tt S}}
\newcommand{\rlan}{{\tt R}}
\newcommand{\ryacas}{{\bf Ryacas}}
\newcommand{\yacas}{{\tt yacas}}
\newcommand{\code}[1]{{\tt #1}}
\def\yac{\texttt{Yacas}}
\def\R{\texttt{R}}
\def\sym{\texttt{Sym}}
\def\yacfun{\texttt{yacas()}}

\setlength{\parindent}{0in}
\setlength{\textwidth}{160mm}
\setlength{\oddsidemargin}{10mm}


\usepackage{fancyvrb}

\newlength{\fancyvrbtopsep}
\newlength{\fancyvrbpartopsep}
\makeatletter
\FV@AddToHook{\FV@ListParameterHook}{\topsep=\fancyvrbtopsep\partopsep=\fancyvrbpartopsep}
\makeatother

\setlength{\fancyvrbtopsep}{0pt}
\setlength{\fancyvrbpartopsep}{0pt}




\title{\ryacas{} -- an \rlan{} interface to the \yacas{} computer
  algebra system}

\author{Rob Goedman, \and
  Gabor Grothendieck, \and
  S{\o}ren H{\o}jsgaard, \and
  Ayal Pinkus}
\date{\ryacas{} version 0.3-1 as of 2017-02-26}

\begin{document}
\maketitle
\tableofcontents
\parskip5pt


%\renewenvironment{Schunk}{\begin{center}
%    \small
%    \begin{boxedminipage}{0.85\textwidth}}{
%    \end{boxedminipage}\end{center}}

%     \RecustomVerbatimEnvironment{Sinput}{Verbatim}%
%         {fontsize=\small,frame=single,framerule=1pt,
%           rulecolor=\color{red},   fillcolor=\color{yellow} }
%     \RecustomVerbatimEnvironment{Soutput}{Verbatim}%
%         {fontsize=\scriptsize, frame=single,framerule=0.1pt}


\section{Introduction}
\label{sec:introduction}

\ryacas{} is an \R\ package that makes the \yacas{} computer algebra
system available from within \rlan. The name \yacas{} is short for
``Yet Another Computer Algebra System''.
\ryacas{} is available on the The Comprehensive R Archive Network
(CRAN) at \url{http://cran.r-project.org/}. In addtition, \ryacas{} is
also described on \url{https://code.google.com/p/ryacas/}.

The \yacas{} program is developed by Ayal Pinkhuis (who is also the
maintainer of \yacas{}) and others, and is available at
\href{http://yacas.sourceforge.net}{http://yacas.sourceforge.net} for
various platforms. This site also containsa comprehensive
documentation and the documentation contains many examples.

The examples given here are largely taken from the \yacas{}
documentation (especially from the introductory chapter) but are
organised differently.

Ressources:

\url{http://yacas.sourceforge.net/ref.book.pdf}



\section{A small session -- polynomials}
\label{sec:small-sess-polyn}

The \ryacas{} package works by sending ``commands'' to \yacas{} which
makes the calculations and returns the result to \R{}. This can be
done in various ways.

\subsection{Calling with \yacas\ commands as text strings}
\label{sec:calling-with-yacas}

A simple way of calling \yacas{} from \R{} is by submitting \yacas\
commands as a text string to the \code{yacas()} function.
\begin{Schunk}
\begin{Sinput}
> out <- yacas( "Expand( (1 + u)^4 )" ); out
\end{Sinput}
\begin{Soutput}
expression(u^4 + 4 * u^3 + 6 * u^2 + 4 * u + 1)
\end{Soutput}
\begin{Sinput}
> class( out )
\end{Sinput}
\begin{Soutput}
[1] "yacas"
\end{Soutput}
\end{Schunk}

Notice that the output from \code{yacas()} looks like an \R\
expression, but it is not; see below.

The result can be displayed nicer in different forms. For example
\begin{Schunk}
\begin{Sinput}
> PrettyForm( out )
\end{Sinput}
\begin{Soutput}
 4        3        2            
u  + 4 * u  + 6 * u  + 4 * u + 1

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> TeXForm( out )
\end{Sinput}
\begin{Soutput}
expression("$u ^{4} + 4 u ^{3} + 6 u ^{2} + 4 u + 1$")
\end{Soutput}
\end{Schunk}

To obtain the tex form as a string to put into a file we can do:
\begin{Schunk}
\begin{Sinput}
> yacas(TeXForm(out), retclass = "unquote")
\end{Sinput}
\end{Schunk}

\subsection{The output from \yacas}
\label{sec:output-from-yacas}

The output from \yacfun\ looks like an \R\ expression, bit it is not;
it is a \code{"yacas"} object.

\begin{Schunk}
\begin{Sinput}
> class( out )
\end{Sinput}
\begin{Soutput}
[1] "yacas"
\end{Soutput}
\begin{Sinput}
> names( out )
\end{Sinput}
\begin{Soutput}
[1] "text"   "OMForm"
\end{Soutput}
\begin{Sinput}
> lapply( out, head )
\end{Sinput}
\begin{Soutput}
$text
expression(u^4 + 4 * u^3 + 6 * u^2 + 4 * u + 1)

$OMForm
[1] "<OMOBJ>\r\n  <OMA>\r\n    <OMS cd=\"arith1\" name=\"plus\"/>\r\n    <OMA>\r\n      <OMS cd=\"arith1\" name=\"plus\"/>\r\n      <OMA>\r\n        <OMS cd=\"arith1\" name=\"plus\"/>\r\n        <OMA>\r\n          <OMS cd=\"arith1\" name=\"plus\"/>\r\n          <OMA>\r\n            <OMS cd=\"arith1\" name=\"power\"/>\r\n            <OMV name=\"u\"/>\r\n            <OMI>4</OMI>\r\n          </OMA>\r\n          <OMA>\r\n            <OMS cd=\"arith1\" name=\"times\"/>\r\n            <OMI>4</OMI>\r\n            <OMA>\r\n              <OMS cd=\"arith1\" name=\"power\"/>\r\n              <OMV name=\"u\"/>\r\n              <OMI>3</OMI>\r\n            </OMA>\r\n          </OMA>\r\n        </OMA>\r\n        <OMA>\r\n          <OMS cd=\"arith1\" name=\"times\"/>\r\n          <OMI>6</OMI>\r\n          <OMA>\r\n            <OMS cd=\"arith1\" name=\"power\"/>\r\n            <OMV name=\"u\"/>\r\n            <OMI>2</OMI>\r\n          </OMA>\r\n        </OMA>\r\n      </OMA>\r\n      <OMA>\r\n        <OMS cd=\"arith1\" name=\"times\"/>\r\n        <OMI>4</OMI>\r\n        <OMV name=\"u\"/>\r\n      </OMA>\r\n    </OMA>\r\n    <OMI>1</OMI>\r\n  </OMA>\r\n</OMOBJ>\r\n"
\end{Soutput}
\end{Schunk}

The \code{text} slot in the output is an \R\ expression that can be
evaluated numerically as
\begin{Schunk}
\begin{Sinput}
> eval( out$text, list(u=1) )
\end{Sinput}
\begin{Soutput}
[1] 16
\end{Soutput}
\end{Schunk}

in \ryacas, there is an \code{Eval()} function that operation that
operates on \verb'yacas' objects so one can also do
\begin{Schunk}
\begin{Sinput}
> Eval( out, list(u=1) )
\end{Sinput}
\begin{Soutput}
[1] 16
\end{Soutput}
\end{Schunk}

\subsection{Calling \yacas\ with \R\ expressions}
\label{sec:calling-yacas-with}

In \ryacas, \R\ expressions can be sent to \code{yacas} so one can do
\begin{Schunk}
\begin{Sinput}
> e <- expression( Expand( (1 + u)^4 ) )
> yacas( e )
\end{Sinput}
\begin{Soutput}
expression(u^4 + 4 * u^3 + 6 * u^2 + 4 * u + 1)
\end{Soutput}
\end{Schunk}

This works fine as long as a valid \R\ expression can be
created -- but consider expanding a polynomial in two variables
\begin{Schunk}
\begin{Sinput}
> e <- expression( Expand((1+x-y)^2, x) )         ## This works
> ## e <- expression( Expand((1+x-y)^2, {x,y}) )  ## This fails
\end{Sinput}
\end{Schunk}
The latter case fails because of the \yacas\ syntax with curly braces
which \R's \code{expression()} function can not interpret. So in the
latter case we have to pass the argument as a text string:
\begin{Schunk}
\begin{Sinput}
> yacas( "Expand((1+x-y)^2, {x,y})" )
\end{Sinput}
\begin{Soutput}
expression(x^2 + (-2 * y + 2) * x + (y^2 - 2 * y + 1))
\end{Soutput}
\end{Schunk}

Another example of an operation that can not be handled using \R\
expressions is differentiation. Doing
\begin{verbatim}
  yacas(expression(D(x)Sin(x)))
\end{verbatim}
produces an error. For such cases we can do
\begin{Schunk}
\begin{Sinput}
> yacas("D(x)Sin(x)")
\end{Sinput}
\begin{Soutput}
expression(cos(x))
\end{Soutput}
\end{Schunk}


\subsection{Using \sym\ objects}


An elegant way of working with \yacas\ is by using \sym\ objects.  A
\sym\ object is a character string that has class \verb'Sym'.  The
function \code{Sym(x)} coerces an object \code{x} to a \sym\ object
by first coercing it to character and then changing its class to
\verb"Sym". For clarity we use two different symbols here:
\begin{Schunk}
\begin{Sinput}
> x_ <- Sym("x")
> x_
\end{Sinput}
\begin{Soutput}
expression(x)
\end{Soutput}
\begin{Sinput}
> dput( x_ )
\end{Sinput}
\begin{Soutput}
structure("x", class = c("Sym", "character"))
\end{Soutput}
\end{Schunk}

One can combine \sym\ objects with other \sym\ objects as well as to
other \R\ objects using \code{+}, \code{-} and other similar \R\
operators. For example
\begin{Schunk}
\begin{Sinput}
> x_ + 4
\end{Sinput}
\begin{Soutput}
expression(x + 4)
\end{Soutput}
\begin{Sinput}
> Eval(x_+4, list(x=1))
\end{Sinput}
\begin{Soutput}
[1] 5
\end{Soutput}
\end{Schunk}

One can apply \code{sin}, \code{cos}, \code{tan}, \code{deriv},
\code{Integrate} and other provided functions to \sym\ objects.
For example:
\begin{Schunk}
\begin{Sinput}
> x <- Sym("x")
> Integrate(sin(x), x)
\end{Sinput}
\begin{Soutput}
expression(-cos(x))
\end{Soutput}
\begin{Sinput}
> deriv(cos(x), x)
\end{Sinput}
\begin{Soutput}
expression(-sin(x))
\end{Soutput}
\end{Schunk}

\subsection{Recall the most recent line -- the \texttt{\%} operator}

The operator \texttt{\%} automatically recalls the result from the
previous line.
\begin{Schunk}
\begin{Sinput}
> yacas("(1+x)^3")
\end{Sinput}
\begin{Soutput}
expression((x + 1)^3)
\end{Soutput}
\begin{Sinput}
> yacas("%")
\end{Sinput}
\begin{Soutput}
expression((x + 1)^3)
\end{Soutput}
\begin{Sinput}
> yacas("z:= %")
\end{Sinput}
\begin{Soutput}
expression((x + 1)^3)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> (1+x)^3
\end{Sinput}
\begin{Soutput}
expression((x + 1)^3)
\end{Soutput}
\begin{Sinput}
> zs <- Sym("%")
> zs
\end{Sinput}
\begin{Soutput}
expression((x + 1)^3)
\end{Soutput}
\end{Schunk}


\subsection{Setting and clearing a variable}
\label{sec:setting-clearing}

The function \code{Set()} and the operator \code{:=} can both be used
to assign values to global variables in \yacas:

\begin{Schunk}
\begin{Sinput}
> yacas("n := 10")
\end{Sinput}
\begin{Soutput}
expression(10)
\end{Soutput}
\begin{Sinput}
> yacas("n := n + n")
\end{Sinput}
\begin{Soutput}
expression(20)
\end{Soutput}
\begin{Sinput}
> yacas("Set(z, Cos(a))")
\end{Sinput}
\begin{Soutput}
expression(TRUE)
\end{Soutput}
\begin{Sinput}
> yacas("z+z")
\end{Sinput}
\begin{Soutput}
expression(2 * cos(a))
\end{Soutput}
\end{Schunk}

Notice that these are variables in \yacas, not in \R.
Variables in \yacas\ can be removed \code{Clear()}
\begin{Schunk}
\begin{Sinput}
> yacas("n")
\end{Sinput}
\begin{Soutput}
expression(20)
\end{Soutput}
\begin{Sinput}
> yacas("Clear(n, z)")
\end{Sinput}
\begin{Soutput}
expression(TRUE)
\end{Soutput}
\begin{Sinput}
> yacas("n")
\end{Sinput}
\begin{Soutput}
expression(n)
\end{Soutput}
\end{Schunk}

Variables in \yacas\ can also be set with \code{Set()} from \R:
\begin{Schunk}
\begin{Sinput}
> Set(m, 10)
\end{Sinput}
\begin{Soutput}
expression(10)
\end{Soutput}
\end{Schunk}

Now \code{m} exists as a variable in \yacas\ (and we
can make computations on this variable as above).
However we have no handle on
this variable in \R. Such a handle is obtained with with \verb'Sym'
objects:
\begin{Schunk}
\begin{Sinput}
> m <- Sym("m")
\end{Sinput}
\end{Schunk}
Now the \R\ variable \code{m} refers to the \yacas\ variable
\code{m} and we can make  calculations directly from \R, e.g:
\begin{Schunk}
\begin{Sinput}
> Set(m, 123)
\end{Sinput}
\begin{Soutput}
expression(123)
\end{Soutput}
\begin{Sinput}
> m^2
\end{Sinput}
\begin{Soutput}
expression(15129)
\end{Soutput}
\end{Schunk}


\section{\yac\ calculations}


\subsection{Symbolic and numerical calculations, precision}
\label{sec:algebr-calc}

\begin{Schunk}
\begin{Sinput}
> yacas(expression( (1/2) / (4/5) ))
\end{Sinput}
\begin{Soutput}
expression(5/8)
\end{Soutput}
\begin{Sinput}
> Sym("1/2") / Sym("4/5") ## WRONG RESULT
\end{Sinput}
\begin{Soutput}
expression(1/40)
\end{Soutput}
\begin{Sinput}
> Sym("1/14 + 5/21 * (30 - 1 + 1/2)")
\end{Sinput}
\begin{Soutput}
expression(149/21)
\end{Soutput}
\begin{Sinput}
> Sym("55/10")
\end{Sinput}
\begin{Soutput}
expression(11/2)
\end{Soutput}
\end{Schunk}

Notice that rational numbers will stay rational as long as numerators
and denominators are integers.


Evaluations are generally exact:
\begin{Schunk}
\begin{Sinput}
> yacas("Exp(0)")
\end{Sinput}
\begin{Soutput}
expression(1)
\end{Soutput}
\begin{Sinput}
> yacas("Exp(1)")
\end{Sinput}
\begin{Soutput}
expression(exp(1))
\end{Soutput}
\begin{Sinput}
> yacas("Sin(Pi/4)")
\end{Sinput}
\begin{Soutput}
expression(root(1/2, 2))
\end{Soutput}
\begin{Sinput}
> yacas("355/113")
\end{Sinput}
\begin{Soutput}
expression(355/113)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> exp(Sym(0))
\end{Sinput}
\begin{Soutput}
expression(1)
\end{Soutput}
\begin{Sinput}
> exp(Sym(1))
\end{Sinput}
\begin{Soutput}
expression(exp(1))
\end{Soutput}
\begin{Sinput}
> sin(Pi/4)
\end{Sinput}
\begin{Soutput}
expression(root(1/2, 2))
\end{Soutput}
\begin{Sinput}
> Sym("355/113")
\end{Sinput}
\begin{Soutput}
expression(355/113)
\end{Soutput}
\end{Schunk}


To obtain a numerical evaluation (approximation), the \code{N()}
function can be used: The \code{N()} function has an optional second
argument, the required precision:

\begin{Schunk}
\begin{Sinput}
> x <- Sym("55/10")
> N( x )
\end{Sinput}
\begin{Soutput}
expression(5.5)
\end{Soutput}
\begin{Sinput}
> Eval( N( x ) )
\end{Sinput}
\begin{Soutput}
[1] 5.5
\end{Soutput}
\begin{Sinput}
> yacas("355/113")
\end{Sinput}
\begin{Soutput}
expression(355/113)
\end{Soutput}
\begin{Sinput}
> N( yacas("355/113"), 8 )
\end{Sinput}
\begin{Soutput}
expression(3.14159292)
\end{Soutput}
\begin{Sinput}
> N( "355/113", 8 )
\end{Sinput}
\begin{Soutput}
expression(3.14159292)
\end{Soutput}
\begin{Sinput}
> 
\end{Sinput}
\end{Schunk}


The command \code{Precision(n)}
can be used to specify that all floating point numbers should have a
fixed precision of n digits:
\begin{Schunk}
\begin{Sinput}
> yacas("Precision(5)")
\end{Sinput}
\begin{Soutput}
expression(Precision(5))
\end{Soutput}
\begin{Sinput}
> yacas("N(355/113)")
\end{Sinput}
\begin{Soutput}
expression(3.1415929203)
\end{Soutput}
\begin{Sinput}
> ## Alternative
> ## Precision(5)
> ## N("355/113")
\end{Sinput}
\end{Schunk}


Combining symbolic and numerical expressions:

\begin{Schunk}
\begin{Sinput}
> x <- Sym("x")
> N(sin(1)^2 + cos(x)^2)
\end{Sinput}
\begin{Soutput}
expression(cos(x)^2 + 0.708073418273571)
\end{Soutput}
\end{Schunk}



%% Symbolic expressions:
%% <<>>=
%% yacas(expression(Factor(x^2-1)))
%% exp1 <- expression(x^2 + 2 * x^2)
%% exp2 <- expression(2 * exp0)
%% exp3 <- expression(6 * pi * x)
%% exp4 <- expression((exp1 * (1 - sin(exp3))) / exp2)
%% yacas(exp4)
%% @

%% @
%% <<>>=
%% xs <- Sym("xs")
%% Factor(xs^2-1)
%% exp1 <- xs^2 + 2 * xs^2
%% exp0 <- Sym("exp0")
%% exp2 <- 2 * Sym(exp0)
%% exp3 <- 6 * Pi * xs
%% exp4 <- exp1 * (1 - sin(exp3)) / exp2
%% exp4
%% @ %def

\subsection{Differentiation}
\label{sec:differentiation}

\begin{Schunk}
\begin{Sinput}
> yacas("D(x) Sin(x)")
\end{Sinput}
\begin{Soutput}
expression(cos(x))
\end{Soutput}
\begin{Sinput}
> yacas("D(x, 2) Sin(x)")
\end{Sinput}
\begin{Soutput}
expression(-sin(x))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> x <- Sym("x")
> deriv(sin(x), x)
\end{Sinput}
\begin{Soutput}
expression(cos(x))
\end{Soutput}
\end{Schunk}


\subsection{Integration}
\label{sec:integration}

%% Integration:
%% @

\begin{Schunk}
\begin{Sinput}
> yacas("Integrate(x,a,b)Sin(x)")
\end{Sinput}
\begin{Soutput}
expression(cos(a) - cos(b))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> a <- Sym("a"); b <- Sym("b")
> Integrate(sin(x), x, a, b)
\end{Sinput}
\begin{Soutput}
expression(cos(a) - cos(b))
\end{Soutput}
\end{Schunk}



\subsection{Expanding polynomials}

\begin{Schunk}
\begin{Sinput}
> yacas("Expand( (1 + x)^3)" )
\end{Sinput}
\begin{Soutput}
expression(x^3 + 3 * x^2 + 3 * x + 1)
\end{Soutput}
\begin{Sinput}
> yacas("Factor( x^2 - 1 )" )
\end{Sinput}
\begin{Soutput}
expression((x + 1) * (x - 1))
\end{Soutput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
> xs <- Sym("xs")
> Expand((1+xs)^3)
\end{Sinput}
\begin{Soutput}
expression(xs^3 + 3 * xs^2 + 3 * xs + 1)
\end{Soutput}
\begin{Sinput}
> Factor(xs^2-1)
\end{Sinput}
\begin{Soutput}
expression((xs + 1) * (xs - 1))
\end{Soutput}
\end{Schunk}


\subsection{Taylor expansion}
\label{sec:taylor-expansion}

\begin{Schunk}
\begin{Sinput}
> yacas("texp := Taylor(x,0,3) Exp(x)")
\end{Sinput}
\begin{Soutput}
expression(x + x^2/2 + x^3/6 + 1)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> xs <- Sym("xs")
\end{Sinput}
\begin{Soutput}
expression(xs)
\end{Soutput}
\begin{Sinput}
> texp <- Taylor(exp(xs), xs, 0, 3)
\end{Sinput}
\begin{Soutput}
expression(xs + xs^2/2 + xs^3/6 + 1)
\end{Soutput}
\end{Schunk}


Expand $\exp(x)$ in three terms
around $0$ and $a$:
\begin{Schunk}
\begin{Sinput}
> yacas("Taylor(x,0,3) Exp(x)")
\end{Sinput}
\begin{Soutput}
expression(x + x^2/2 + x^3/6 + 1)
\end{Soutput}
\begin{Sinput}
> yacas("Taylor(x,a,3) Exp(x)")
\end{Sinput}
\begin{Soutput}
expression(exp(a) + exp(a) * (x - a) + (x - a)^2 * exp(a)/2 + 
    (x - a)^3 * exp(a)/6)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> xs <- Sym("xs")
> Taylor(exp(xs),xs,0,3)
\end{Sinput}
\begin{Soutput}
expression(xs + xs^2/2 + xs^3/6 + 1)
\end{Soutput}
\begin{Sinput}
> as <- Sym("as")
> Taylor(exp(x),x,as,3)
\end{Sinput}
\begin{Soutput}
expression(exp(as) + exp(as) * (x - as) + (x - as)^2 * exp(as)/2 + 
    (x - as)^3 * exp(as)/6)
\end{Soutput}
\end{Schunk}

\subsection{Inverse Taylor}
\label{sec:inverse-taylor}


The \code{InverseTaylor()} function builds the Taylor series expansion
of the inverse of an expression. For example, the Taylor expansion in
two terms of the inverse of $\exp(x)$ around $x=0$ (which is the
Taylor expansion of $\ln(y)$ around $y=1$):
\begin{Schunk}
\begin{Sinput}
> yacas("InverseTaylor(x,0,2)Exp(x)")
\end{Sinput}
\begin{Soutput}
expression(x - 1 - (x - 1)^2/2)
\end{Soutput}
\begin{Sinput}
> yacas("Taylor(y,1,2)Ln(y)")
\end{Sinput}
\begin{Soutput}
expression(y - 1 - (y - 1)^2/2)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> ys <- Sym("ys"); xs <- Sym("xs")
> InverseTaylor(exp(xs),xs,0,2)
\end{Sinput}
\begin{Soutput}
expression(xs + xs^2/2 + 1)
\end{Soutput}
\begin{Sinput}
> Taylor(log(ys),ys,1,2)
\end{Sinput}
\begin{Soutput}
expression(ys - 1 - (ys - 1)^2/2)
\end{Soutput}
\end{Schunk}


\subsection{Factorial}

\begin{Schunk}
\begin{Sinput}
> yacas("40!")
\end{Sinput}
\begin{Soutput}
expression(8.15915283247898e+47)
\end{Soutput}
\begin{Sinput}
> yacas("40!", retclass = "character")
\end{Sinput}
\begin{Soutput}
815915283247897734345611269596115894272000000000 
\end{Soutput}
\begin{Sinput}
> Factorial(40)
\end{Sinput}
\begin{Soutput}
expression(Factorial(40))
\end{Soutput}
\end{Schunk}



\subsection{Limits}
\begin{Schunk}
\begin{Sinput}
> yacas( "Limit(x,0) Sin(x)/x" )
\end{Sinput}
\begin{Soutput}
expression(1)
\end{Soutput}
\begin{Sinput}
> yacas( "Limit(n,Infinity) (1+(1/n))^n" )
\end{Sinput}
\begin{Soutput}
expression(exp(1))
\end{Soutput}
\begin{Sinput}
> yacas( "Limit(h,0) (Sin(x+h)-Sin(x))/h" )
\end{Sinput}
\begin{Soutput}
expression(cos(x))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> x <- Sym("x"); n <- Sym("n"); h <- Sym("h")
> Limit( sin(x) / x, x, 0)
\end{Sinput}
\begin{Soutput}
expression(1)
\end{Soutput}
\begin{Sinput}
> Limit( (1 + (1 / n))^n, n, Infinity )
\end{Sinput}
\begin{Soutput}
expression(exp(1))
\end{Soutput}
\begin{Sinput}
> Limit( (sin(x + h) - sin(x) ) / h, h, 0)
\end{Sinput}
\begin{Soutput}
expression(cos(x))
\end{Soutput}
\end{Schunk}


\subsection{Simplifying an expression}

The function Simplify() attempts to reduce an expression
to a simpler form.
\begin{Schunk}
\begin{Sinput}
> y <- Sym("y")
> yacas("(x+y)^3-(x-y)^3")
\end{Sinput}
\begin{Soutput}
expression((x + y)^3 - (x - y)^3)
\end{Soutput}
\begin{Sinput}
> yacas("Simplify(%)")
\end{Sinput}
\begin{Soutput}
expression(6 * (x^2 * y) + 2 * y^3)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> (x+y)^3-(x-y)^3
\end{Sinput}
\begin{Soutput}
expression((x + y)^3 - (x - y)^3)
\end{Soutput}
\begin{Sinput}
> Simplify("%")
\end{Sinput}
\begin{Soutput}
expression(6 * (x^2 * y) + 2 * y^3)
\end{Soutput}
\end{Schunk}



\subsection{Complex numbers and the imaginary unit}

The imaginary unit $i$ is denoted \verb'I' and complex numbers can be
entered as either expressions involving \verb'I' or explicitly
\code{Complex(a,b)}
for $a+ib$.
\begin{Schunk}
\begin{Sinput}
> yacas("I")
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(0, 1))
\end{Soutput}
\begin{Sinput}
> yacas("I^2")
\end{Sinput}
\begin{Soutput}
expression(-1)
\end{Soutput}
\begin{Sinput}
> yacas("7+3*I")
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(7, 3))
\end{Soutput}
\begin{Sinput}
> yacas("Conjugate(%)")
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(7, -3))
\end{Soutput}
\begin{Sinput}
> yacas("Exp(3*I)")
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(cos(3), sin(3)))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> I
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(0, 1))
\end{Soutput}
\begin{Sinput}
> I^2
\end{Sinput}
\begin{Soutput}
expression(-1)
\end{Soutput}
\begin{Sinput}
> 7+3*I
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(7, 3))
\end{Soutput}
\begin{Sinput}
> Conjugate("%")
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(7, -3))
\end{Soutput}
\begin{Sinput}
> exp(3*I)
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(cos(3), sin(3)))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> z <- 7+3*I
> 1/z
\end{Sinput}
\begin{Soutput}
expression(complex_cartesian(7/58, -3/58))
\end{Soutput}
\begin{Sinput}
> z*(1/z)
\end{Sinput}
\begin{Soutput}
expression(1)
\end{Soutput}
\end{Schunk}

We get the famous identity $\exp(i\pi)=-1$ with
\begin{Schunk}
\begin{Sinput}
> exp(I*Pi)
\end{Sinput}
\begin{Soutput}
expression(-1)
\end{Soutput}
\end{Schunk}

\subsection{Solving equations}

\subsubsection{Solving equations symbolically}

Solve equations symbolically with the \code{Solve()} function:
\begin{Schunk}
\begin{Sinput}
> yacas("Solve(x/(1+x) == a, x)")
\end{Sinput}
\begin{Soutput}
expression(list(x == a/(1 - a)))
\end{Soutput}
\begin{Sinput}
> yacas("Solve(x^2+x == 0, x)")
\end{Sinput}
\begin{Soutput}
expression(list(x == 0, x == -1))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> Solve(xs/(1+xs) == as, xs)
\end{Sinput}
\begin{Soutput}
expression(list(xs == as/(1 - as)))
\end{Soutput}
\begin{Sinput}
> Solve(xs^2+xs == 0, xs)
\end{Sinput}
\begin{Soutput}
expression(list(xs == 0, xs == -1))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> Solve(List(xs^2+ys^2==6, xs-ys==3), List(xs,ys))
\end{Sinput}
\begin{Soutput}
expression(list(list(xs == root(6 - ys^2, 2), ys == ys)))
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> mu <- Sym("mu") # mean
> v <- Sym("v") # variance
> Solve(List(mu==(xs/(xs+ys)), v==((xs*ys)/(((xs+ys)^2) * (xs+ys+1)))),
+     List(xs,ys))
\end{Sinput}
\begin{Soutput}
expression(list(list(xs == mu^2 * (1 - mu)/v - mu, ys == xs/mu - 
    xs)))
\end{Soutput}
\end{Schunk}

(Note the use of the == operator, which does not evaluate to anything,
to denote an "equation" object.)

\subsubsection{Solving equations numerically}
To solve an equation (in one variable) like $sin(x)-exp(x)=0$ numerically taking $0.5$
as initial guess and an accuracy of $0.0001$ do:
\begin{Schunk}
\begin{Sinput}
> yacas("Newton(Sin(x)-Exp(x),x, 0.5, 0.0001)")
\end{Sinput}
\begin{Soutput}
expression(-3.1830630118)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> Newton(sin(xs)-exp(xs),xs, 0.5, 0.0001)
\end{Sinput}
\begin{Soutput}
expression(-3.1830630118)
\end{Soutput}
\end{Schunk}



\subsection{Solving ordinary differential equations}

\begin{Schunk}
\begin{Sinput}
> yacas("OdeSolve(y''==4*y)")
\end{Sinput}
\begin{Soutput}
expression(C12403 * exp(2 * x) + C12407 * exp(-2 * x))
\end{Soutput}
\begin{Sinput}
> yacas("OdeSolve(y'==8*y)")
\end{Sinput}
\begin{Soutput}
expression(C12437 * exp(8 * x))
\end{Soutput}
\end{Schunk}


\section{Matrices}
\label{sec:matrices}

\begin{Schunk}
\begin{Sinput}
> PrettyPrinter()
\end{Sinput}
\begin{Soutput}
expression(PrettyPrinter())
\end{Soutput}
\end{Schunk}


\begin{Schunk}
\begin{Sinput}
> A <- yacas( "A:={{4,-2,4,2},{-2,10,-2,-7},{4,-2,8,4},{2,-7,4,7}}" )
> PrettyForm(A) ## FIXME: SHOULD THIS WORK??
\end{Sinput}
\begin{Soutput}
list( list( 4 , -2 , 4 , 2 ) , list( -2 , 10 , -2 , -7 ) , 

list( 4 , -2 , 8 , 4 ) , list( 2 , -7 , 4 , 7 ) )

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> yacas("PrettyForm(A)")
\end{Sinput}
\begin{Soutput}
/                              \
| ( 4 )  ( -2 ) ( 4 )  ( 2 )   |
|                              |
| ( -2 ) ( 10 ) ( -2 ) ( -7 )  |
|                              |
| ( 4 )  ( -2 ) ( 8 )  ( 4 )   |
|                              |
| ( 2 )  ( -7 ) ( 4 )  ( 7 )   |
\                              /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> R <- yacas("R := Cholesky(A)")
> yacas("PrettyForm(R)")
\end{Sinput}
\begin{Soutput}
/                            \
| ( 2 ) ( -1 ) ( 2 ) ( 1 )   |
|                            |
| ( 0 ) ( 3 )  ( 0 ) ( -2 )  |
|                            |
| ( 0 ) ( 0 )  ( 2 ) ( 1 )   |
|                            |
| ( 0 ) ( 0 )  ( 0 ) ( 1 )   |
\                            /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> yacas("RtR:=Transpose(R) * R")
\end{Sinput}
\begin{Soutput}
expression(list(list(4, -2, 4, 2), list(-2, 10, -2, -7), list(4, 
    -2, 8, 4), list(2, -7, 4, 7)))
\end{Soutput}
\begin{Sinput}
> yacas("PrettyForm(RtR)")
\end{Sinput}
\begin{Soutput}
/                              \
| ( 4 )  ( -2 ) ( 4 )  ( 2 )   |
|                              |
| ( -2 ) ( 10 ) ( -2 ) ( -7 )  |
|                              |
| ( 4 )  ( -2 ) ( 8 )  ( 4 )   |
|                              |
| ( 2 )  ( -7 ) ( 4 )  ( 7 )   |
\                              /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\end{Schunk}


\begin{Schunk}
\begin{Sinput}
> yacas("M:={ {u1,u1,0},{u1,0,u2},{0,u2,0} }")
\end{Sinput}
\begin{Soutput}
expression(list(list(u1, u1, 0), list(u1, 0, u2), list(0, u2, 
    0)))
\end{Soutput}
\begin{Sinput}
> yacas("PrettyForm(M)")
\end{Sinput}
\begin{Soutput}
/                       \
| ( u1 ) ( u1 ) ( 0 )   |
|                       |
| ( u1 ) ( 0 )  ( u2 )  |
|                       |
| ( 0 )  ( u2 ) ( 0 )   |
\                       /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> u1 <- Sym("u1"); u2 <- Sym("u2")
> M <- List(List(u1, u1, 0), List(u1, 0, u2), List(0, u2, 0))
> PrettyForm( M )
\end{Sinput}
\begin{Soutput}
/                       \
| ( u1 ) ( u1 ) ( 0 )   |
|                       |
| ( u1 ) ( 0 )  ( u2 )  |
|                       |
| ( 0 )  ( u2 ) ( 0 )   |
\                       /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\end{Schunk}


\begin{Schunk}
\begin{Sinput}
> yacas(TeXForm(M), retclass = "unquote")
\end{Sinput}
\end{Schunk}


\subsection{Inverse}

\begin{Schunk}
\begin{Sinput}
> yacas("Mi:=Inverse( M )")
\end{Sinput}
\begin{Soutput}
expression(list(list(u2^2/(u1 * u2^2), 0, -(u1 * u2)/(u1 * u2^2)), 
    list(0, 0, u1 * u2/(u1 * u2^2)), list(-(u1 * u2)/(u1 * u2^2), 
        u1 * u2/(u1 * u2^2), u1^2/(u1 * u2^2))))
\end{Soutput}
\begin{Sinput}
> yacas("Simplify( Mi )")
\end{Sinput}
\begin{Soutput}
expression(list(list(1/u1, 0, -1/u2), list(0, 0, 1/u2), list(-1/u2, 
    1/u2, u1/u2^2)))
\end{Soutput}
\begin{Sinput}
> yacas("PrettyForm(Simplify( Mi ))")
\end{Sinput}
\begin{Soutput}
/                        \
| / 1  \ ( 0 )  / -1 \   |
| | -- |        | -- |   |
| \ u1 /        \ u2 /   |
|                        |
| ( 0 )  ( 0 )  / 1  \   |
|               | -- |   |
|               \ u2 /   |
|                        |
| / -1 \ / 1  \ / u1  \  |
| | -- | | -- | | --- |  |
| \ u2 / \ u2 / |   2 |  |
|               \ u2  /  |
\                        /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\end{Schunk}


\begin{Schunk}
\begin{Sinput}
> Mi <- Inverse( M )
> Simplify( Mi )
\end{Sinput}
\begin{Soutput}
expression(list(list(1/u1, 0, -1/u2), list(0, 0, 1/u2), list(-1/u2, 
    1/u2, u1/u2^2)))
\end{Soutput}
\begin{Sinput}
> PrettyForm(Simplify( Mi ))
\end{Sinput}
\begin{Soutput}
/                        \
| / 1  \ ( 0 )  / -1 \   |
| | -- |        | -- |   |
| \ u1 /        \ u2 /   |
|                        |
| ( 0 )  ( 0 )  / 1  \   |
|               | -- |   |
|               \ u2 /   |
|                        |
| / -1 \ / 1  \ / u1  \  |
| | -- | | -- | | --- |  |
| \ u2 / \ u2 / |   2 |  |
|               \ u2  /  |
\                        /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\end{Schunk}

\subsection{Determinant}

\begin{Schunk}
\begin{Sinput}
> yacas("Determinant( M )")
\end{Sinput}
\begin{Soutput}
expression(-(u1 * u2^2))
\end{Soutput}
\begin{Sinput}
> yacas("Determinant( Mi )") ## FIXME: Whats up here?
\end{Sinput}
\begin{Soutput}
expression(-(u2^2 * (u1 * u2)^2)/(u1 * u2^2)^3)
\end{Soutput}
\begin{Sinput}
> yacas("Simplify( Mi )")
\end{Sinput}
\begin{Soutput}
expression(list(list(1/u1, 0, -1/u2), list(0, 0, 1/u2), list(-1/u2, 
    1/u2, u1/u2^2)))
\end{Soutput}
\begin{Sinput}
> yacas("Simplify(Determinant( Mi ))") ## FIXME: Whats up here?
\end{Sinput}
\begin{Soutput}
expression(-1/(u2^2 * u1))
\end{Soutput}
\end{Schunk}


\begin{Schunk}
\begin{Sinput}
> determinant( M )
\end{Sinput}
\begin{Soutput}
expression(-(u1 * u2^2))
\end{Soutput}
\begin{Sinput}
> determinant( Mi )
\end{Sinput}
\begin{Soutput}
expression(-(u2^2 * (u1 * u2)^2)/(u1 * u2^2)^3)
\end{Soutput}
\begin{Sinput}
> Simplify( Mi )
\end{Sinput}
\begin{Soutput}
expression(list(list(1/u1, 0, -1/u2), list(0, 0, 1/u2), list(-1/u2, 
    1/u2, u1/u2^2)))
\end{Soutput}
\begin{Sinput}
> Simplify(determinant( Mi ))
\end{Sinput}
\begin{Soutput}
expression(-1/(u2^2 * u1))
\end{Soutput}
\end{Schunk}




\section{Printing with PrettyForm, PrettyPrint, TexForm and  TeXForm}
\label{sec:printing}



Printing the result in nice forms:
\begin{Schunk}
\begin{Sinput}
> yacas("PrettyForm(texp)")
\end{Sinput}
\begin{Soutput}
     2    3    
    x    x     
x + -- + -- + 1
    2    6     

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> yacas("TeXForm(texp)", retclass = "unquote")
\end{Sinput}
\begin{Soutput}
$x + \frac{x ^{2}}{2}  + \frac{x ^{3}}{6}  + 1$
\end{Soutput}
\end{Schunk}


\begin{Schunk}
\begin{Sinput}
> yacas("TeXForm(texp)", retclass = "unquote")
\end{Sinput}
$x + \frac{x ^{2}}{2}  + \frac{x ^{3}}{6}  + 1$\end{Schunk}


\begin{Schunk}
\begin{Sinput}
> PrettyForm(texp)
\end{Sinput}
\begin{Soutput}
       2     3    
     xs    xs     
xs + --- + --- + 1
      2     6     

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> TeXForm(texp)
\end{Sinput}
\begin{Soutput}
expression("$xs + \frac{xs ^{2}}{2}  + \frac{xs ^{3}}{6}  + 1$")
\end{Soutput}
\end{Schunk}

There are different ways of displaying the output.


\subsubsection{Standard form}
The (standard)
yacas form is:
\begin{Schunk}
\begin{Sinput}
> yacas("A:={{a,b},{c,d}}")
\end{Sinput}
\begin{Soutput}
expression(list(list(a, b), list(c, d)))
\end{Soutput}
\begin{Sinput}
> yacas("B:= (1+x)^2+k^3")
\end{Sinput}
\begin{Soutput}
expression((x + 1)^2 + k^3)
\end{Soutput}
\begin{Sinput}
> yacas("A")
\end{Sinput}
\begin{Soutput}
expression(list(list(a, b), list(c, d)))
\end{Soutput}
\begin{Sinput}
> yacas("B")
\end{Sinput}
\begin{Soutput}
expression((x + 1)^2 + k^3)
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> as <- Sym("as"); bs <- Sym("bs"); cs <- Sym("cs"); ds <- Sym("ds")
> A <- List(List(as,bs), List(cs,ds))
> ks <- Sym("ks")
> B <- (1+xs)^2+ks^3
> A
\end{Sinput}
\begin{Soutput}
expression(list(list(as, bs), list(cs, ds)))
\end{Soutput}
\begin{Sinput}
> B
\end{Sinput}
\begin{Soutput}
expression((xs + 1)^2 + ks^3)
\end{Soutput}
\end{Schunk}


\subsubsection{Pretty form}
The Pretty form is:
\begin{Schunk}
\begin{Sinput}
> yacas("PrettyForm(A)")
\end{Sinput}
\begin{Soutput}
/              \
| ( a ) ( b )  |
|              |
| ( c ) ( d )  |
\              /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> yacas("PrettyForm(B)")
\end{Sinput}
\begin{Soutput}
         2    3
( x + 1 )  + k 

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> PrettyForm(A)
\end{Sinput}
\begin{Soutput}
/                \
| ( as ) ( bs )  |
|                |
| ( cs ) ( ds )  |
\                /

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\begin{Sinput}
> PrettyForm(B)
\end{Sinput}
\begin{Soutput}
          2     3
( xs + 1 )  + ks 

<OMOBJ>
  <OMS cd="logic1" name="true"/>
</OMOBJ>
\end{Soutput}
\end{Schunk}



\subsubsection{TeX form}

The output can be displayed in TeX form:
\begin{Schunk}
\begin{Sinput}
> yacas("TeXForm(B)", retclass = "character")
\end{Sinput}
\begin{Soutput}
'$\left( x + 1\right)  ^{2} + k ^{3}$'
\end{Soutput}
\end{Schunk}

This function sets up the function printer to print out the results on
the command line. This can be reset to the internal printer with
PrettyPrinter().

Currently implemented prettyprinters are: PrettyForm, TeXForm, Print
and DefaultPrint.

\begin{Schunk}
\begin{Sinput}
> PrettyPrinter()
\end{Sinput}
\begin{Soutput}
expression(PrettyPrinter())
\end{Soutput}
\end{Schunk}


%% %%% -------------------------------------------------------------
%% \section{Miscellaneous}
%% \label{sec:misc}



%% Note that the value returned by \yacas\ can be of different types:
%% @
%% <<print=T>>=
%% yacas(expression(Factor(x^2-1)),retclass='unquote')
%% yacas(expression(Factor(x^2-1)),retclass='character')
%% @ %def


\end{document}





%% It is important to note the difference between the \R\ name \code{x}
%% and the symbol \code{"x"} as illustrated below:
%% @
%% <<print=T>>=
%% x<- Sym("xs")
%% x
%% x+4
%% Eval(x+4, list(xs=5))
%% @ %def




%% The convention in the following is 1) that \sym\ objects match with
%% their names that they end with an 's', e.g.
%% @
%% <<>>=
%% xs <- Sym("xs")
%% @ %def




%% Now we can do:
%% @
%% <<eval=T>>=
%% Expand( (1 + x_)^4 )
%% @ %def




%% there is a \code{Expand()} function that calls the
%% \code{Expand} function in \yacas. T

%% However, it is NOT VALID to write
%% @
%% <<eval=F>>=
%% Expand( (1 + u)^4 )
%% @ %def
%% But - it is valid to wrap the above into an \R\ expression and call








%% @
%% <<>>=
%% x_ <- Sym("x")
%% y_ <- Sym("y")
%% Expand( (1 + x_)^4 )
%% Expand((1+x_-y_)^2, x_)
%% ## Expand((1+x_-y_)^2, {x_,y_})
%% @ %def






%% Expand((1+x-y)^2, x);
%% Expand((1+x-y)^2, {x,y})

%% \section{\R\ expressions,  \yacas\ expressions and \sym\ objects}
%% \label{sec:hood}

%% The \ryacas{} package works by sending ``commands'' to \yacas{} which
%% makes the calculations and returns the result to \R{}. This can be
%% done in various ways.








%% \subsection{\R\ expressions}

%% A call to \yacas\ may be in the form of an \R\ expression which
%% involves valid R calls, symbols or constants (though not all valid \R\
%% expressions are valid). For example:
%% @
%% <<print=T>>=
%% exp1<- yacas(expression(Factor(x^2-1)))
%% @ %def

%% The result \code{exp1} is not an expression in the \R\ sense but an
%% object of class \code{"yacas"}.
%% To evaluate the resulting expression numerically, we can do
%% @
%% <<>>=
%% Eval(exp1, list(x=4))
%% @ %def

%% \subsection{\yacas\ expressions}

%% Some commands are not proper \R\ expressions. For example,
%% typing
%% \begin{verbatim}
%%   yacas(expression(D(x)Sin(x)))
%% \end{verbatim}
%% produces an error.
%% For such cases we can make
%% a specification using the \yacas{} syntax:
%% @
%% <<>>=
%% yacas("D(x)Sin(x)")
%% @ %def


%% \subsection{\sym\ objects}

%% Probably the most elegant way of working with \yacas\ is by using
%% \sym\ objects.
%% A \sym\ object is a \yacas\ character string that has the "Sym" class.
%% One can combine \sym\ objects with other \sym\ objects as well as to
%% other \R\ objects using \code{+}, \code{-} and other similar \R\
%% operators.

%% The function \code{Sym(x)} coerces an object \code{x} to a \sym\ object by
%% first coercing it to character and then changing its class to "Sym":
%% @
%% <<print=T>>=
%% x<- Sym("x")
%% @ %def

%% Operations on \sym\ objects lead to new \sym\ objects:
%% @
%% <<print=T>>=
%% x+4
%% @ %def

%% One can apply \code{sin}, \code{cos}, \code{tan}, \code{deriv}, \code{Integrate}
%% and other provided functions to \sym\ objects. For example:
%% @
%% <<>>=
%% Integrate(sin(x), x)
%% @ %def
%% In this way the communication with \yacas\ is ``tacit''.

%% It is important to note the difference between the \R\ name \code{x}
%% and the symbol \code{"x"} as illustrated below:
%% @
%% <<print=T>>=
%% x<- Sym("xs")
%% x
%% x+4
%% Eval(x+4, list(xs=5))
%% @ %def

%% The convention in the following is 1) that \sym\ objects match with
%% their names that they end with an 's', e.g.
%% @
%% <<>>=
%% xs <- Sym("xs")
%% @ %def



%% \section{A sample session}
%% \label{sec:samplesession}





%% Algebraic calculations:
%% @
%% <<>>=
%% yacas(expression((10 + 2) * 5 + 7^7))
%% yacas(expression(1/14+5/21* (30- 1+ 1/2)))
%% @ %def

%% @
%% <<>>=
%% #(Sym(10) + Sym(2)) * Sym(5) + Sym(7) ^ Sym(7)
%% Sym("10 * 2") * 5 + Sym(7) ^ 7
%% #(Sym(10) + 2) * 5 + Sym(7) ^ 7
%% #Sym("(10+2)*5 + 7^7")
%% Sym("1/14 + 5/21 * (30 - 1+1/2)")
%% @ %def

%% Numerical evaluations:
%% @
%% <<>>=
%% yacas(expression(N(-12/2)))
%% @ %def
%% @
%% <<>>=
%% Sym("-12/2")
%% #Eval(Sym("-12/2"))
%% @ %def


%% Likewise:
%% @
%% <<>>=
%% as <- Sym("as")
%% zs <- Sym("zs")
%% Set(zs, cos(as))
%% zs + zs
%% @ %def


%% o clear a variable
%% binding execute \code{Clear()}:
%% @
%% <<>>=
%% yacas(expression(n))
%% yacas("Clear(n)")
%% yacas(expression(n))
%% @ %def

%% @
%% <<>>=
%% Set(ns, 1)
%% ns <- Sym("ns")
%% ns
%% Clear(ns)
%% ns
%% @ %def


%% \subsection{Symbolic and numerical evaluations, precision}

%% Evaluations are generally exact:
%% @
%% <<>>=
%% yacas("Exp(0)")
%% yacas("Exp(1)")
%% yacas("Sin(Pi/4)")
%% yacas("355/113")
%% @ %def

%% @
%% <<>>=
%% exp(Sym(0))
%% exp(Sym(1))
%% sin(Pi/4)
%% Sym("355/113")
%% @ %def

%%  To obtain a numerical evaluation
%% (approximation), the \code{N()} function can be used:
%% @
%% <<>>=
%% yacas("N(Exp(1))")
%% yacas("N(Sin(Pi/4))")
%% yacas("N(355/113)")
%% @ %def

%% @
%% <<>>=
%% N(exp(1))
%% N(sin(Pi/4))
%% N(355/113)
%% @ %def

%% @
%% <<>>=
%% yacas("N(355/133,20)")
%% @ %def

%% @
%% <<>>=
%% N("355/113",20)
%% @ %def


%% The command \code{Precision(n)}
%% can be used to specify that all floating point numbers should have a
%% fixed precision of n digits:
%% @
%% <<>>=
%% yacas("Precision(5)")
%% yacas("N(355/113)")
%% @ %def

%% @
%% <<>>=
%% Precision(5)
%% N("355/113")
%% @ %def


%% \subsection{Rational numbers}

%% Rational numbers will stay rational as long as the numerator and
%% denominator are integers:
%% @
%% <<>>=
%% yacas(expression(55/10))
%% @ %def

%% @
%% <<>>=
%% Sym("55 / 10")
%% @ %def


%% \subsection{Symbolic calculation}
%% \label{sec:symbolicCalculation}

%% Some exact manipulations :
%% @
%% <<>>=
%% yacas("1/14+5/21*(30-(1+1/2)*5^2)")
%% yacas("0+x")
%% yacas("x+1*y")
%% yacas("Sin(ArcSin(alpha))+Tan(ArcTan(beta))")
%% @ %def

%% @
%% <<>>=
%% Sym("1/14+5/21*(1*30-(1+1/2)*5^2)")
%% xs <- Sym("xs")
%% ys <- Sym("ys")
%% 0+xs
%% xs+1*ys
%% sin(asin(xs))+tan(atan(ys))
%% @ %def



%% \subsection{Analytical derivatives}

%% Analytical derivatives of functions can be evaluated with the
%% \code{D()} and \code{deriv()} functions:
%% @
%% <<>>=
%% yacas("D(x) Sin(x)")
%% @ %def

%% @
%% <<>>=
%% deriv(sin(xs), xs)
%% @ %def

%% These functions also accepts an argument specifying how often the
%% derivative has to be taken, e.g:
%% @
%% <<>>=
%% yacas("D(x,4)Sin(x)")
%% @ %def

%% @
%% <<>>=
%% deriv(sin(xs),xs,4)
%% @ %def

%% \subsection{Integration}

%% @
%% <<echo=F,results=hide>>=
%% yacas("Clear(a,b,A,B)")
%% @ %def

%% @
%% <<>>=
%% #yacas("Integrate(x,a,b)Sin(x)")
%% #yacas("Integrate(x,a,b)Ln(x)+x")
%% #yacas("Integrate(x)1/(x^2-1)")
%% yacas("Integrate(x)Sin(a*x)^2*Cos(b*x)")
%% @ %def


%% @
%% <<>>=
%% out <- yacas("Integrate(x)Sin(a*x)^2*Cos(b*x)")
%% @ %def



%% @
%% <<>>=
%% #Integrate(sin(x),x,a,b)
%% #Integrate(log(x),x,a,b)
%% #Integrate(1/(x^2-1),x)
%% a <- Sym("a")
%% b <- Sym("b")
%% Integrate(sin(a*x)^2*cos(b*x),x)
%% @ %def


%% \subsection{Variable substitution}

%% @
%% <<>>=
%% yacas("Subst(x,Cos(a))x+x")
%% @ %def

%% @
%% <<>>=
%% Subst(xs+xs,xs,cos(as))
%% @ %def


