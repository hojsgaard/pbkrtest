---
title: "Mixed models in some generality"
author: "Søren Højsgaard"
date: "`r date()`"
format: 
  html:
    toc: true
    toc-depth: 4
    number-sections: true
    number-depth: 5
    self-contained: true
  pdf: 
    toc: true
    toc-depth: 4
    number-sections: true
    number-depth: 5
    papersize: a4
    fontsize: 12pt
---

\def\transp{^\top}
\def\inv{^{-1}}
\def\E{\mathbb{E}}
\def\EE{\mathbb{E}}
\def\Var{\mathbb{V}\text{ar}}
\def\Cov{\mathbb{C}\text{ov}}
\def\Corr{\mathbb{C}\text{orr}}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=!TRUE, size="footnotesize", warning = FALSE, message = FALSE, fig.height=2.5)
options("digits"=4)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")

options("width"=120)
options(caracas.print.method = "prettyascii") 
#options(caracas.print.method = "compactascii") 
#options(caracas.print.method = "ascii") 
options(caracas.print.method = "utf8") 

```


```{r}
library(parallel)
library(Matrix)
library(caracas)
library(broom)
library(doBy)
library(nlme)
library(lme4)
library(broom.mixed)
library(microbenchmark)
##source("free_parms.R")
source("caracas_head_tail.R")
source("nlme_lme4_extension.R")
source("fit_mixed.R")
```


# Beyond linear normal models


Recall LMM

$$
y = Xb + Zu + e
$$

With lmer() only spherical errors are allowed, i.e. $e\sim N(0,
\sigma^2I)$. The variance of $y$ is $V=ZGZ\transp + R$. 

With gls(), a wide class of $V$ matrices can be used, but there are limitations. 



## Orthodont data

Recall Orthodont data: Four measurements per child at equidistant time
points. There is a population intercept for each gender and a random
intercept for each child. Thee is a linear treand over time, and on
can consider the idea of modelling a random slope.

The ultimate goal is to fit a model where there is a random intercept
but where the errors are not $e\sim N(0, \sigma^2I)$ but has an auto
regressive structure.

For each child we assume an AR(1) correlation matrix.  The correlation
matrix for all is a block diagonal matrix with the matrix above on the
diagonal. An easy way of creating such a matrix is using Kronecker
product. Here for two children

General point

1. Construct V=ZGZ' + R symbolically. 
1. Convert V to a function Vfun of the covariance parameters. Do this only once. 
1. Construct general worker function that takes (Vfun, X, y) as input and returns (b.hat, var(b.hat), Q, detV).
1. Construct general logL function that invokes worker and returns logL.

## Beet data


```{r}
dat <- doBy::beets
dat$bh <- dat |> with(block:harvest)
lmm1 <- lmer(sugpct ~ block + harvest + sow + (1|block:harvest), data=dat, REML=F)
lme1 <- lme(sugpct ~ block + harvest + sow, random = ~ 1 | bh,
            method="ML", data = dat)
lgm1 <- gls(sugpct ~ block + harvest + sow,
           corCompSymm(form = ~ 1 | block/harvest),
           method="ML", data = dat)
```



```{r}
X <- getME(lmm1, "X")
Z <- getME(lmm1, "Z")
y <- getME(lmm1, "y")
def_sym(sigma, omega)

G <- diag_("omega^2", ncol(Z))
Z <- as_sym(Z)
ZGZt <- Z %*% G %*% t(Z)

R1 <- sigma^2 * diag_(1, nrow(Z))
V <- ZGZt + R1
V |> head(8)

Vfun <- as_func(V, vec_arg = T)
args(Vfun)
V. <- Vfun(c(1,3))
V.

parm <- c(omega=.2, sigma=1)
transf_vv(parm)
wrapper_vv(parm)

opt <- optim(parm, wrapper_vv)
opt$par |> transf_vv()

```




## Fit AR(1) model

Simulate data and fit ar(1)

```{r}
n <- 15
r <- 0.8
set.seed(1411)
y <- arima.sim(n = n, list(ar = r), sd=1) |> as.numeric()
a <- ar(y, order=1, method="mle")
a$ar
a$var.pred
```

Setup for fitting mixed model with AR(1) errors

```{r}
def_sym(r)
X <- matrix(rep(1, length(y)))
R <- make_ar1(r, n)
V <- sigma^2 * R
V[1:5, 1:5] 
Vfun <- as_func(V, vec_arg = T)
args(Vfun)
```



```{r}
parm <- c(r=.1, sigma=1)
opt <- optim(parm, wrapper_cv)
opt$par |> transf_cv()

## Work on logL0 directly
eps <- 1e-6
opt1 <- optim(parm, logL0)
opt1 <- nlminb(parm, logL0, lower=c(-1+eps,0), upper=c(1-eps, Inf))
opt2 <- nlminb(parm, logL0, lower=c(-1+eps,0), upper=c(1-eps, Inf))

opt1$par
opt2$par
```

## Timing:

```{r, eval=F}
microbenchmark(
  optim(parm, logL0),
  nlminb(parm, logL0),
  times=3
)
```


## Random intercept and AR(1) error

## Orthodont data

### Using lmer and gls

```{r}
dat <- Orthodont[c(1:8, 101:108),]
dat <- as.data.frame(dat)
lmm1 <- lmer(distance ~ age + Sex + (1|Subject), data=dat, REML=F)
lmm1 |> tidy()

lme1 <- lme(distance ~ age + Sex,
            random= ~1 | Subject,
            correlation= corAR1(form = ~ 1 | Subject),
           method="ML", data = dat)

gls1 <- gls(distance ~ age + Sex,
           corAR1(form = ~ 1 | Subject),
           method="ML", data = dat)
```



```{r}
y   <- getME(lmm1, "y")
X   <- getME(lmm1, "X")
Z   <- getME(lmm1, "Z")

def_sym(sigma, omega)
G <- diag_("omega^2", ncol(Z))
Z <- as_sym(Z)
ZGZt <- Z %*% G %*% t(Z)
ZGZt |> dim()
```

### Random intercept 


```{r}
R <- diag_("sigma^2", nrow(Z))
V <- ZGZt + R
V |> head(8)

Vfun <- as_func(V, vec_arg = T)
args(Vfun)
```

```{r}
parm <- c(omega=1, sigma=1)
Vfun |> args()
V. <- Vfun(parm)
V.
opt <- optim(parm, wrapper_vv)
opt$par |> transf_vv()
```


### Random intercept and AR(1) errors

```{r}
def_sym(sigma)
ZGZt <- block_ri(~Subject, data=dat)$ZGZt
R <- sigma^2 * block_ar1(~ 1 | Subject, data=dat)
R

V <- ZGZt + R
Vfun <- as_func(V, vec_arg = T)
args(Vfun)
```


```{r}
parm <- c(omega=.1, r=0, sigma=1)
Vfun |> args()
V. <- Vfun(parm)
V.

opt <- optim(parm, wrapper_vcv)
opt
opt$par |> transf_vcv()
```

