%\VignetteEngine{knitr::knitr} 
%\VignettePackage{doBy}
%\VignetteIndexEntry{section_fun: Section functions to a smaller domain}

\documentclass[11pt]{article}\usepackage[]{graphicx}\usepackage[]{xcolor}
% maxwidth is the original width if it is less than linewidth
% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%
\let\hlipl\hlkwb

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage{hyperref,url,color,Sweave,a4wide}
\usepackage[utf8]{inputenc}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}

\RequirePackage{color,fancyvrb,amsmath,amsfonts}

%\def\textasciigrave{'}
\def\proglang#1{{#1}}
\def\R{\proglang{R}}
\def\pkg#1{{\bf #1}}
\def\doby{\pkg{doBy}}
\def\code#1{\texttt{#1}}
\def\summaryby{\code{summaryBy}}

% reduce whitespace between R code and R output
% \let\oldknitrout\knitrout
% \renewenvironment{knitrout}{
%   \begin{oldknitrout}
%     \footnotesize
%     \topsep=0pt
% }{
%   \end{oldknitrout}
% }



\title{Section functions to a smaller domain with \texttt{section\_fun()} in the \texttt{doBy} package}
\author{S{\o}ren H{\o}jsgaard}
\date{\pkg{doBy} version 4.6.21 as of 2024-04-29}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}
% \SweaveOpts{concordance=TRUE}


\maketitle
\tableofcontents
\parindent0pt
\parskip5pt



% show R> prompt before R commands




\definecolor{darkred}{rgb}{.7,0,0}
\definecolor{midnightblue}{rgb}{0.098,0.098,0.439}


\section{Introduction}
\label{sec:introduction}


The \doby{} package contains a variety of utility functions. This
working document describes some of these functions. The package
originally grew out of a need to calculate groupwise summary
statistics (much in the spirit of \code{PROC SUMMARY} of the
\proglang{SAS} system), but today the package contains many different
utilities.




\section{Section a functions domain: \code{section\_fun()}}
\label{sec:section}


Let $f(x,y)=x+y$. Then $f_x(y)=f(10, y)$ is a
section of $f$ to be a function of $y$ alone.

More generally, let $E$ be a subset of the cartesian product $X \times Y$ where $X$
and $Y$ are some sets. Consider a function $f(x,y)$ defined on
$E$. Then for any $x \in X$, the section of $E$ defined by $x$
(denoted $E_x$) is the set of $y$'s in $Y$ such that $(x, y)$ is in
$E$, i.e.
$$
 E_x = \{ y \in Y | (x,y) \in E\}
$$

Correspondingly, the section of $f(x,y)$ defined by $x$ is the
function $f_x$ defined on $E_x$ given by $f_x(y)=f(x,y)$.

There are the following approaches:

1) insert the section values as default values in the function definition (default),
2) insert the section values in the function body,
3) store the section values in an auxillary environment.

Consider this function:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{fun}  \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{a}\hlstd{,} \hlkwc{b}\hlstd{,} \hlkwc{c}\hlstd{=}\hlnum{4}\hlstd{,} \hlkwc{d}\hlstd{=}\hlnum{9}\hlstd{)\{}
\hlstd{  }    \hlstd{a} \hlopt{+} \hlstd{b} \hlopt{+} \hlstd{c} \hlopt{+} \hlstd{d}
\hlstd{  }\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{fun_def} \hlkwb{<-} \hlkwd{section_fun}\hlstd{(fun,} \hlkwd{list}\hlstd{(}\hlkwc{b}\hlstd{=}\hlnum{7}\hlstd{,} \hlkwc{d}\hlstd{=}\hlnum{10}\hlstd{))}
\hlstd{> }\hlstd{fun_def}
\end{alltt}
\begin{verbatim}
## function (a, c = 4, b = 7, d = 10) 
## {
##     a + b + c + d
## }
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlstd{fun_body} \hlkwb{<-} \hlkwd{section_fun}\hlstd{(fun,} \hlkwd{list}\hlstd{(}\hlkwc{b}\hlstd{=}\hlnum{7}\hlstd{,} \hlkwc{d}\hlstd{=}\hlnum{10}\hlstd{),} \hlkwc{method}\hlstd{=}\hlstr{"sub"}\hlstd{)}
\hlstd{> }\hlstd{fun_body}
\end{alltt}
\begin{verbatim}
## function(a, c=4)
## { 
##  ## section
##  b = 7;
##  d = 10
##  ## section (end)
##  a + b + c + d
## }
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlstd{fun_env} \hlkwb{<-} \hlkwd{section_fun}\hlstd{(fun,} \hlkwd{list}\hlstd{(}\hlkwc{b}\hlstd{=}\hlnum{7}\hlstd{,} \hlkwc{d}\hlstd{=}\hlnum{10}\hlstd{),} \hlkwc{method} \hlstd{=} \hlstr{"env"}\hlstd{)}
\hlstd{> }\hlstd{fun_env}
\end{alltt}
\begin{verbatim}
## function (a, c = 4) 
## {
##     . <- "use get_section(function_name) to see section"
##     . <- "use get_fun(function_name) to see original function"
##     args <- arg_getter()
##     do.call(fun, args)
## }
## <environment: 0x56bb6c5a77a0>
\end{verbatim}
\end{kframe}
\end{knitrout}

In the last case, we can see the section and the original function definition as:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlkwd{get_section}\hlstd{(fun_env)}
\end{alltt}
\begin{verbatim}
## $b
## [1] 7
## 
## $d
## [1] 10
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlcom{## same as: attr(fun_env, "arg_env")$args }
\hlstd{> }\hlkwd{get_fun}\hlstd{(fun_env)}
\end{alltt}
\begin{verbatim}
## function(a, b, c=4, d=9){
##     a + b + c + d
## }
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlcom{## same as: environment(fun_env)$fun}
\end{alltt}
\end{kframe}
\end{knitrout}


We get:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlkwd{fun}\hlstd{(}\hlkwc{a}\hlstd{=}\hlnum{10}\hlstd{,} \hlkwc{b}\hlstd{=}\hlnum{7}\hlstd{,} \hlkwc{c}\hlstd{=}\hlnum{5}\hlstd{,} \hlkwc{d}\hlstd{=}\hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 32
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlkwd{fun_def}\hlstd{(}\hlkwc{a}\hlstd{=}\hlnum{10}\hlstd{,} \hlkwc{c}\hlstd{=}\hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 32
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlkwd{fun_body}\hlstd{(}\hlkwc{a}\hlstd{=}\hlnum{10}\hlstd{,} \hlkwc{c}\hlstd{=}\hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 32
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlkwd{fun_env}\hlstd{(}\hlkwc{a}\hlstd{=}\hlnum{10}\hlstd{,} \hlkwc{c}\hlstd{=}\hlnum{5}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 32
\end{verbatim}
\end{kframe}
\end{knitrout}



\section{Example: Benchmarking}
\label{sec:exampl-benchm}


Consider a simple task: Creating and inverting Toeplitz matrices for increasing dimensions: 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{n} \hlkwb{<-} \hlnum{4}
\hlstd{> }\hlkwd{toeplitz}\hlstd{(}\hlnum{1}\hlopt{:}\hlstd{n)}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    2    1    2    3
## [3,]    3    2    1    2
## [4,]    4    3    2    1
\end{verbatim}
\end{kframe}
\end{knitrout}

A naive implementation is
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{inv_toep} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{n}\hlstd{) \{}
\hlstd{  }    \hlkwd{solve}\hlstd{(}\hlkwd{toeplitz}\hlstd{(}\hlnum{1}\hlopt{:}\hlstd{n))}
\hlstd{  }\hlstd{\}}
\hlstd{> }\hlkwd{inv_toep}\hlstd{(}\hlnum{4}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,] -0.4  0.5  0.0  0.1
## [2,]  0.5 -1.0  0.5  0.0
## [3,]  0.0  0.5 -1.0  0.5
## [4,]  0.1  0.0  0.5 -0.4
\end{verbatim}
\end{kframe}
\end{knitrout}

We can benchmark timing for different values of $n$ as
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlkwd{library}\hlstd{(microbenchmark)}
\hlstd{> }\hlkwd{microbenchmark}\hlstd{(}
\hlstd{  }    \hlkwd{inv_toep}\hlstd{(}\hlnum{4}\hlstd{),} \hlkwd{inv_toep}\hlstd{(}\hlnum{8}\hlstd{),} \hlkwd{inv_toep}\hlstd{(}\hlnum{16}\hlstd{),}
\hlstd{  }    \hlkwd{inv_toep}\hlstd{(}\hlnum{32}\hlstd{),} \hlkwd{inv_toep}\hlstd{(}\hlnum{64}\hlstd{),}
\hlstd{  }    \hlkwc{times}\hlstd{=}\hlnum{5}
\hlstd{  }\hlstd{)}
\end{alltt}
\begin{verbatim}
## Unit: microseconds
##          expr    min     lq   mean median     uq     max neval cld
##   inv_toep(4)  12.30  13.00  15.21  13.08  14.84   22.84     5   a
##   inv_toep(8)  13.99  14.33  15.02  14.99  15.71   16.10     5   a
##  inv_toep(16)  21.22  21.27  22.02  21.91  21.96   23.72     5   a
##  inv_toep(32)  48.62  48.90  50.40  49.16  50.76   54.59     5   a
##  inv_toep(64) 160.34 169.51 475.13 175.16 179.32 1691.34     5   a
\end{verbatim}
\end{kframe}
\end{knitrout}

However, it is tedious (and hence error prone) to write these function calls. 

A programmatic approach using \code{section\_fun} is as follows: First create a list of sectioned functions:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{n.vec}  \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{3}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{5}\hlstd{)}
\hlstd{> }\hlstd{fun_list} \hlkwb{<-} \hlkwd{lapply}\hlstd{(n.vec,}
\hlstd{  }                  \hlkwa{function}\hlstd{(}\hlkwc{ni}\hlstd{)\{}
\hlstd{  }                      \hlkwd{section_fun}\hlstd{(inv_toep,} \hlkwd{list}\hlstd{(}\hlkwc{n}\hlstd{=ni))\}}
\hlstd{  }                  \hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can inspect and evaluate each / all functions as:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{fun_list[[}\hlnum{1}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## function (n = 3) 
## {
##     solve(toeplitz(1:n))
## }
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlstd{fun_list[[}\hlnum{1}\hlstd{]]()}
\end{alltt}
\begin{verbatim}
##        [,1] [,2]   [,3]
## [1,] -0.375  0.5  0.125
## [2,]  0.500 -1.0  0.500
## [3,]  0.125  0.5 -0.375
\end{verbatim}
\end{kframe}
\end{knitrout}

To use the list of functions in connection with microbenchmark we bquote all functions using

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{bquote_list} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{fnlist}\hlstd{)\{}
\hlstd{  }    \hlkwd{lapply}\hlstd{(fnlist,} \hlkwa{function}\hlstd{(}\hlkwc{g}\hlstd{) \{}
\hlstd{  }        \hlkwd{bquote}\hlstd{(}\hlkwd{.}\hlstd{(g)())}
\hlstd{  }    \hlstd{\}}
\hlstd{  }    \hlstd{)}
\hlstd{  }\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

We get:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{bq_fun_list} \hlkwb{<-} \hlkwd{bquote_list}\hlstd{(fun_list)}
\hlstd{> }\hlstd{bq_fun_list[[}\hlnum{1}\hlstd{]]}
\end{alltt}
\begin{verbatim}
## (function (n = 3) 
## {
##     solve(toeplitz(1:n))
## })()
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlcom{## Evaluate one:}
\hlstd{> }\hlkwd{eval}\hlstd{(bq_fun_list[[}\hlnum{1}\hlstd{]])}
\end{alltt}
\begin{verbatim}
##        [,1] [,2]   [,3]
## [1,] -0.375  0.5  0.125
## [2,]  0.500 -1.0  0.500
## [3,]  0.125  0.5 -0.375
\end{verbatim}
\begin{alltt}
\hlstd{> }\hlcom{## Evaluate all:}
\hlstd{> }\hlcom{## lapply(bq_fun_list, eval)}
\end{alltt}
\end{kframe}
\end{knitrout}

To use microbenchmark we must name the elements of the list:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlkwd{names}\hlstd{(bq_fun_list)} \hlkwb{<-} \hlstd{n.vec}
\hlstd{> }\hlkwd{microbenchmark}\hlstd{(}
\hlstd{  }  \hlkwc{list}  \hlstd{= bq_fun_list,}
\hlstd{  }  \hlkwc{times} \hlstd{=} \hlnum{5}
\hlstd{  }\hlstd{)}
\end{alltt}
\begin{verbatim}
## Unit: microseconds
##  expr   min    lq  mean median    uq   max neval cld
##     3 11.07 11.12 25.14  11.37 13.47 78.69     5   a
##     4 11.56 11.83 14.29  12.58 14.30 21.18     5   a
##     5 12.19 12.31 15.38  13.24 15.32 23.84     5   a
\end{verbatim}
\end{kframe}
\end{knitrout}


Running the code below provides a benchmark of the different ways of sectioning in terms of speed.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{> }\hlstd{n.vec}  \hlkwb{<-} \hlkwd{seq}\hlstd{(}\hlnum{20}\hlstd{,} \hlnum{80}\hlstd{,} \hlkwc{by}\hlstd{=}\hlnum{20}\hlstd{)}
\hlstd{> }\hlstd{fun_def} \hlkwb{<-} \hlkwd{lapply}\hlstd{(n.vec,}
\hlstd{  }                  \hlkwa{function}\hlstd{(}\hlkwc{ni}\hlstd{)\{}
\hlstd{  }                      \hlkwd{section_fun}\hlstd{(inv_toep,} \hlkwd{list}\hlstd{(}\hlkwc{n}\hlstd{=ni),} \hlkwc{method}\hlstd{=}\hlstr{"def"}\hlstd{)\}}
\hlstd{  }                  \hlstd{)}
\hlstd{> }\hlstd{fun_body} \hlkwb{<-} \hlkwd{lapply}\hlstd{(n.vec,}
\hlstd{  }                  \hlkwa{function}\hlstd{(}\hlkwc{ni}\hlstd{)\{}
\hlstd{  }                      \hlkwd{section_fun}\hlstd{(inv_toep,} \hlkwd{list}\hlstd{(}\hlkwc{n}\hlstd{=ni),} \hlkwc{method}\hlstd{=}\hlstr{"sub"}\hlstd{)\}}
\hlstd{  }                  \hlstd{)}
\hlstd{> }\hlstd{fun_env} \hlkwb{<-} \hlkwd{lapply}\hlstd{(n.vec,}
\hlstd{  }                  \hlkwa{function}\hlstd{(}\hlkwc{ni}\hlstd{)\{}
\hlstd{  }                      \hlkwd{section_fun}\hlstd{(inv_toep,} \hlkwd{list}\hlstd{(}\hlkwc{n}\hlstd{=ni),} \hlkwc{method}\hlstd{=}\hlstr{"env"}\hlstd{)\}}
\hlstd{  }                  \hlstd{)}
\hlstd{> }
\hlstd{> }\hlstd{bq_fun_list} \hlkwb{<-} \hlkwd{bquote_list}\hlstd{(}\hlkwd{c}\hlstd{(fun_def, fun_body, fun_env))}
\hlstd{> }\hlkwd{names}\hlstd{(bq_fun_list)} \hlkwb{<-} \hlkwd{paste0}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"def"}\hlstd{,} \hlstr{"body"}\hlstd{,} \hlstr{"env"}\hlstd{),} \hlkwc{each}\hlstd{=}\hlkwd{length}\hlstd{(n.vec)),} \hlkwd{rep}\hlstd{(n.vec,} \hlnum{3}\hlstd{))}
\hlstd{> }
\hlstd{> }\hlstd{mb} \hlkwb{<-} \hlkwd{microbenchmark}\hlstd{(}
\hlstd{  }  \hlkwc{list}  \hlstd{= bq_fun_list,}
\hlstd{  }  \hlkwc{times} \hlstd{=} \hlnum{2}
\hlstd{  }\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


\end{document}


