\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{hyperref,a4,color,boxedminipage,Sweave}
%\VignetteIndexEntry{Introduction to Ryacas}
%\VignettePackage{Ryacas}
%\VignetteDepends{XML}

\usepackage{textcomp}

% Definitions
\newcommand{\slan}{{\tt S}}
\newcommand{\rlan}{{\tt R}}
\newcommand{\ryacas}{{\bf Ryacas}}
\newcommand{\yacas}{{\tt yacas}}
\newcommand{\code}[1]{{\tt #1}}
\def\yac{\texttt{Yacas}}
\def\R{\texttt{R}}
\def\sym{\texttt{Sym}}
\def\yacfun{\texttt{yacas()}}

\setlength{\parindent}{0in}
\setlength{\textwidth}{160mm}
\setlength{\oddsidemargin}{10mm}


\usepackage{fancyvrb}

\newlength{\fancyvrbtopsep}
\newlength{\fancyvrbpartopsep}
\makeatletter
\FV@AddToHook{\FV@ListParameterHook}{\topsep=\fancyvrbtopsep\partopsep=\fancyvrbpartopsep}
\makeatother

\setlength{\fancyvrbtopsep}{0pt}
\setlength{\fancyvrbpartopsep}{0pt}


<<echo=FALSE,print=FALSE>>=
rm(list=ls())
require( Ryacas )
prettyVersion <- packageDescription("Ryacas")$Version
prettyDate <- format(Sys.Date())
@


\title{\ryacas{} -- an \rlan{} interface to the \yacas{} computer
  algebra system}

\author{Rob Goedman, \and
  Gabor Grothendieck, \and
  S{\o}ren H{\o}jsgaard, \and
  Ayal Pinkus}
\date{\ryacas{} version \Sexpr{prettyVersion} as of \Sexpr{prettyDate}}

\begin{document}
\maketitle
\tableofcontents
\parskip5pt

<<echo=FALSE, results=hide>>=
library(Ryacas)
options(width=80)
@

\renewenvironment{Schunk}{\begin{center}
    \small
    \begin{boxedminipage}{0.85\textwidth}}{
    \end{boxedminipage}\end{center}}

%     \RecustomVerbatimEnvironment{Sinput}{Verbatim}%
%         {fontsize=\small,frame=single,framerule=1pt,
%           rulecolor=\color{red},   fillcolor=\color{yellow} }
%     \RecustomVerbatimEnvironment{Soutput}{Verbatim}%
%         {fontsize=\scriptsize, frame=single,framerule=0.1pt}


\section{Introduction}
\label{sec:introduction}

\ryacas{} is an \R\ package that makes the \yacas{} computer algebra
system available from within \rlan. The name \yacas{} is short for
``Yet Another Computer Algebra System''.
\ryacas{} is available on the The Comprehensive R Archive Network
(CRAN) at \url{http://cran.r-project.org/}. In addtition, \ryacas{} is
also described on \url{https://code.google.com/p/ryacas/}.

The \yacas{} program is developed by Ayal Pinkhuis (who is also the
maintainer of \yacas{}) and others, and is available at
\href{http://yacas.sourceforge.net}{http://yacas.sourceforge.net} for
various platforms. This site also containsa comprehensive
documentation and the documentation contains many examples.

The examples given here are largely taken from the \yacas{}
documentation (especially from the introductory chapter) but are
organised differently.

Ressources:

\url{http://yacas.sourceforge.net/ref.book.pdf}



\section{A small session -- polynomials}
\label{sec:small-sess-polyn}

The \ryacas{} package works by sending ``commands'' to \yacas{} which
makes the calculations and returns the result to \R{}. This can be
done in various ways.

\subsection{Calling with \yacas\ commands as text strings}
\label{sec:calling-with-yacas}

A simple way of calling \yacas{} from \R{} is by submitting \yacas\
commands as a text string to the \code{yacas()} function.
@
<<>>=
out <- yacas( "Expand( (1 + u)^4 )" ); out
class( out )
@ %def

Notice that the output from \code{yacas()} looks like an \R\
expression, but it is not; see below.

The result can be displayed nicer in different forms. For example
@
<<>>=
PrettyForm( out )
TeXForm( out )
@ %def

To obtain the tex form as a string to put into a file we can do:
@
<<>>=
yacas(TeXForm(out), retclass = "unquote")
@ %def

\subsection{The output from \yacas}
\label{sec:output-from-yacas}

The output from \yacfun\ looks like an \R\ expression, bit it is not;
it is a \code{"yacas"} object.

@
<<>>=
class( out )
names( out )
lapply( out, head )
@ %def

The \code{text} slot in the output is an \R\ expression that can be
evaluated numerically as
@
<<>>=
eval( out$text, list(u=1) )
@ %def

in \ryacas, there is an \code{Eval()} function that operation that
operates on \verb'yacas' objects so one can also do
@
<<>>=
Eval( out, list(u=1) )
@ %def

\subsection{Calling \yacas\ with \R\ expressions}
\label{sec:calling-yacas-with}

In \ryacas, \R\ expressions can be sent to \code{yacas} so one can do
@
<<>>=
e <- expression( Expand( (1 + u)^4 ) )
yacas( e )
@ %def

This works fine as long as a valid \R\ expression can be
created -- but consider expanding a polynomial in two variables
@
<<>>=
e <- expression( Expand((1+x-y)^2, x) )         ## This works
## e <- expression( Expand((1+x-y)^2, {x,y}) )  ## This fails
@ %def
The latter case fails because of the \yacas\ syntax with curly braces
which \R's \code{expression()} function can not interpret. So in the
latter case we have to pass the argument as a text string:
@
<<>>=
yacas( "Expand((1+x-y)^2, {x,y})" )
@ %def

Another example of an operation that can not be handled using \R\
expressions is differentiation. Doing
\begin{verbatim}
  yacas(expression(D(x)Sin(x)))
\end{verbatim}
produces an error. For such cases we can do
@
<<>>=
yacas("D(x)Sin(x)")
@ %def


\subsection{Using \sym\ objects}


An elegant way of working with \yacas\ is by using \sym\ objects.  A
\sym\ object is a character string that has class \verb'Sym'.  The
function \code{Sym(x)} coerces an object \code{x} to a \sym\ object
by first coercing it to character and then changing its class to
\verb"Sym". For clarity we use two different symbols here:
@
<<>>=
x_ <- Sym("x")
x_
dput( x_ )
@ %def

One can combine \sym\ objects with other \sym\ objects as well as to
other \R\ objects using \code{+}, \code{-} and other similar \R\
operators. For example
@
<<print=T>>=
x_ + 4
Eval(x_+4, list(x=1))
@ %def

One can apply \code{sin}, \code{cos}, \code{tan}, \code{deriv},
\code{Integrate} and other provided functions to \sym\ objects.
For example:
@
<<>>=
x <- Sym("x")
Integrate(sin(x), x)
deriv(cos(x), x)
@ %def

\subsection{Recall the most recent line -- the \texttt{\%} operator}

The operator \texttt{\%} automatically recalls the result from the
previous line.
@
<<>>=
yacas("(1+x)^3")
yacas("%")
yacas("z:= %")
@ %def

@
<<>>=
(1+x)^3
zs <- Sym("%")
zs
@ %def


\subsection{Setting and clearing a variable}
\label{sec:setting-clearing}

The function \code{Set()} and the operator \code{:=} can both be used
to assign values to global variables in \yacas:

@
<<>>=
yacas("n := 10")
yacas("n := n + n")
yacas("Set(z, Cos(a))")
yacas("z+z")
@ %def

Notice that these are variables in \yacas, not in \R.
Variables in \yacas\ can be removed \code{Clear()}
@
<<>>=
yacas("n")
yacas("Clear(n, z)")
yacas("n")
@ %def

Variables in \yacas\ can also be set with \code{Set()} from \R:
@
<<>>=
Set(m, 10)
@ %def

Now \code{m} exists as a variable in \yacas\ (and we
can make computations on this variable as above).
However we have no handle on
this variable in \R. Such a handle is obtained with with \verb'Sym'
objects:
@
<<>>=
m <- Sym("m")
@ %def
Now the \R\ variable \code{m} refers to the \yacas\ variable
\code{m} and we can make  calculations directly from \R, e.g:
@
<<>>=
Set(m, 123)
m^2
@ %def


\section{\yac\ calculations}


\subsection{Symbolic and numerical calculations, precision}
\label{sec:algebr-calc}

@
<<>>=
yacas(expression( (1/2) / (4/5) ))
Sym("1/2") / Sym("4/5") ## WRONG RESULT
Sym("1/14 + 5/21 * (30 - 1 + 1/2)")
Sym("55/10")
@ %def

Notice that rational numbers will stay rational as long as numerators
and denominators are integers.


Evaluations are generally exact:
@
<<>>=
yacas("Exp(0)")
yacas("Exp(1)")
yacas("Sin(Pi/4)")
yacas("355/113")
@ %def

@
<<>>=
exp(Sym(0))
exp(Sym(1))
sin(Pi/4)
Sym("355/113")
@ %def


To obtain a numerical evaluation (approximation), the \code{N()}
function can be used: The \code{N()} function has an optional second
argument, the required precision:

@
<<>>=
x <- Sym("55/10")
N( x )
Eval( N( x ) )
yacas("355/113")
N( yacas("355/113"), 8 )
N( "355/113", 8 )

@ %def


The command \code{Precision(n)}
can be used to specify that all floating point numbers should have a
fixed precision of n digits:
@
<<>>=
yacas("Precision(5)")
yacas("N(355/113)")
## Alternative
## Precision(5)
## N("355/113")
@ %def


Combining symbolic and numerical expressions:

@
<<>>=
x <- Sym("x")
N(sin(1)^2 + cos(x)^2)
@ %def



%% Symbolic expressions:
%% <<>>=
%% yacas(expression(Factor(x^2-1)))
%% exp1 <- expression(x^2 + 2 * x^2)
%% exp2 <- expression(2 * exp0)
%% exp3 <- expression(6 * pi * x)
%% exp4 <- expression((exp1 * (1 - sin(exp3))) / exp2)
%% yacas(exp4)
%% @

%% @
%% <<>>=
%% xs <- Sym("xs")
%% Factor(xs^2-1)
%% exp1 <- xs^2 + 2 * xs^2
%% exp0 <- Sym("exp0")
%% exp2 <- 2 * Sym(exp0)
%% exp3 <- 6 * Pi * xs
%% exp4 <- exp1 * (1 - sin(exp3)) / exp2
%% exp4
%% @ %def

\subsection{Differentiation}
\label{sec:differentiation}

<<>>=
yacas("D(x) Sin(x)")
yacas("D(x, 2) Sin(x)")
@

@
<<>>=
x <- Sym("x")
deriv(sin(x), x)
@ %def


\subsection{Integration}
\label{sec:integration}

%% Integration:
%% @
<<echo=F,results=hide>>=
yacas("Clear(a,b,A,B)")
@ %def

@
<<>>=
yacas("Integrate(x,a,b)Sin(x)")
@ %def

@
<<>>=
a <- Sym("a"); b <- Sym("b")
Integrate(sin(x), x, a, b)
@ %def



\subsection{Expanding polynomials}

@
<<>>=
yacas("Expand( (1 + x)^3)" )
yacas("Factor( x^2 - 1 )" )
@
@
<<>>=
xs <- Sym("xs")
Expand((1+xs)^3)
Factor(xs^2-1)
@ %def


\subsection{Taylor expansion}
\label{sec:taylor-expansion}

@
<<>>=
yacas("texp := Taylor(x,0,3) Exp(x)")
@ %def

@
<<print=T>>=
xs <- Sym("xs")
texp <- Taylor(exp(xs), xs, 0, 3)
@ %def


Expand $\exp(x)$ in three terms
around $0$ and $a$:
@
<<>>=
yacas("Taylor(x,0,3) Exp(x)")
yacas("Taylor(x,a,3) Exp(x)")
@ %def

@
<<>>=
xs <- Sym("xs")
Taylor(exp(xs),xs,0,3)
as <- Sym("as")
Taylor(exp(x),x,as,3)
@ %def

\subsection{Inverse Taylor}
\label{sec:inverse-taylor}


The \code{InverseTaylor()} function builds the Taylor series expansion
of the inverse of an expression. For example, the Taylor expansion in
two terms of the inverse of $\exp(x)$ around $x=0$ (which is the
Taylor expansion of $\ln(y)$ around $y=1$):
@
<<>>=
yacas("InverseTaylor(x,0,2)Exp(x)")
yacas("Taylor(y,1,2)Ln(y)")
@ %def

@
<<>>=
ys <- Sym("ys"); xs <- Sym("xs")
InverseTaylor(exp(xs),xs,0,2)
Taylor(log(ys),ys,1,2)
@ %def


\subsection{Factorial}

@
<<>>=
yacas("40!")
yacas("40!", retclass = "character")
Factorial(40)
@ %def



\subsection{Limits}
@
<<>>=
yacas( "Limit(x,0) Sin(x)/x" )
yacas( "Limit(n,Infinity) (1+(1/n))^n" )
yacas( "Limit(h,0) (Sin(x+h)-Sin(x))/h" )
@ %def

@
<<>>=
x <- Sym("x"); n <- Sym("n"); h <- Sym("h")
Limit( sin(x) / x, x, 0)
Limit( (1 + (1 / n))^n, n, Infinity )
Limit( (sin(x + h) - sin(x) ) / h, h, 0)
@ %def


\subsection{Simplifying an expression}

The function Simplify() attempts to reduce an expression
to a simpler form.
@
<<>>=
y <- Sym("y")
yacas("(x+y)^3-(x-y)^3")
yacas("Simplify(%)")
@ %def

@
<<>>=
(x+y)^3-(x-y)^3
Simplify("%")
@ %def



\subsection{Complex numbers and the imaginary unit}

The imaginary unit $i$ is denoted \verb'I' and complex numbers can be
entered as either expressions involving \verb'I' or explicitly
\code{Complex(a,b)}
for $a+ib$.
@
<<>>=
yacas("I")
yacas("I^2")
yacas("7+3*I")
yacas("Conjugate(%)")
yacas("Exp(3*I)")
@ %def

@
<<>>=
I
I^2
7+3*I
Conjugate("%")
exp(3*I)
@ %def

@
<<>>=
z <- 7+3*I
1/z
z*(1/z)
@ %def

We get the famous identity $\exp(i\pi)=-1$ with
@
<<>>=
exp(I*Pi)
@ %def

\subsection{Solving equations}

\subsubsection{Solving equations symbolically}

Solve equations symbolically with the \code{Solve()} function:
@
<<>>=
yacas("Solve(x/(1+x) == a, x)")
yacas("Solve(x^2+x == 0, x)")
@ %def

<<>>=
Solve(xs/(1+xs) == as, xs)
Solve(xs^2+xs == 0, xs)
@ %def

<<>>=
Solve(List(xs^2+ys^2==6, xs-ys==3), List(xs,ys))
@ %def

<<>>=
mu <- Sym("mu") # mean
v <- Sym("v") # variance
Solve(List(mu==(xs/(xs+ys)), v==((xs*ys)/(((xs+ys)^2) * (xs+ys+1)))),
    List(xs,ys))
@ %def

(Note the use of the == operator, which does not evaluate to anything,
to denote an "equation" object.)

\subsubsection{Solving equations numerically}
To solve an equation (in one variable) like $sin(x)-exp(x)=0$ numerically taking $0.5$
as initial guess and an accuracy of $0.0001$ do:
@
<<>>=
yacas("Newton(Sin(x)-Exp(x),x, 0.5, 0.0001)")
@ %def

@
<<>>=
Newton(sin(xs)-exp(xs),xs, 0.5, 0.0001)
@ %def



\subsection{Solving ordinary differential equations}

@
<<>>=
yacas("OdeSolve(y''==4*y)")
yacas("OdeSolve(y'==8*y)")
@ %def


\section{Matrices}
\label{sec:matrices}

@
<<>>=
PrettyPrinter()
@ %def


@
<<>>=
A <- yacas( "A:={{4,-2,4,2},{-2,10,-2,-7},{4,-2,8,4},{2,-7,4,7}}" )
PrettyForm(A) ## FIXME: SHOULD THIS WORK??
yacas("PrettyForm(A)")
R <- yacas("R := Cholesky(A)")
yacas("PrettyForm(R)")
yacas("RtR:=Transpose(R) * R")
yacas("PrettyForm(RtR)")
@ %def


@
<<>>=
yacas("M:={ {u1,u1,0},{u1,0,u2},{0,u2,0} }")
yacas("PrettyForm(M)")
@ %def

@
<<>>=
u1 <- Sym("u1"); u2 <- Sym("u2")
M <- List(List(u1, u1, 0), List(u1, 0, u2), List(0, u2, 0))
PrettyForm( M )
@ %def


@
<<results=tex>>=
yacas(TeXForm(M), retclass = "unquote")
@ %def


\subsection{Inverse}

@
<<>>=
yacas("Mi:=Inverse( M )")
yacas("Simplify( Mi )")
yacas("PrettyForm(Simplify( Mi ))")
@ %def


@
<<>>=
Mi <- Inverse( M )
Simplify( Mi )
PrettyForm(Simplify( Mi ))
@ %def

\subsection{Determinant}

@
<<>>=
yacas("Determinant( M )")
yacas("Determinant( Mi )") ## FIXME: Whats up here?
yacas("Simplify( Mi )")
yacas("Simplify(Determinant( Mi ))") ## FIXME: Whats up here?
@ %def


@
<<>>=
determinant( M )
determinant( Mi )
Simplify( Mi )
Simplify(determinant( Mi ))
@ %def




\section{Printing with PrettyForm, PrettyPrint, TexForm and  TeXForm}
\label{sec:printing}



Printing the result in nice forms:
@
<<>>=
yacas("PrettyForm(texp)")
yacas("TeXForm(texp)", retclass = "unquote")
@ %def


@
<<results=tex>>=
yacas("TeXForm(texp)", retclass = "unquote")
@ %def


@
<<>>=
PrettyForm(texp)
TeXForm(texp)
@ %def

There are different ways of displaying the output.


\subsubsection{Standard form}
The (standard)
yacas form is:
@
<<>>=
yacas("A:={{a,b},{c,d}}")
yacas("B:= (1+x)^2+k^3")
yacas("A")
yacas("B")
@ %def

@
<<>>=
as <- Sym("as"); bs <- Sym("bs"); cs <- Sym("cs"); ds <- Sym("ds")
A <- List(List(as,bs), List(cs,ds))
ks <- Sym("ks")
B <- (1+xs)^2+ks^3
A
B
@ %def


\subsubsection{Pretty form}
The Pretty form is:
@
<<>>=
yacas("PrettyForm(A)")
yacas("PrettyForm(B)")
@ %def

@
<<>>=
PrettyForm(A)
PrettyForm(B)
@ %def



\subsubsection{TeX form}

The output can be displayed in TeX form:
@
<<>>=
yacas("TeXForm(B)", retclass = "character")
@ %def

This function sets up the function printer to print out the results on
the command line. This can be reset to the internal printer with
PrettyPrinter().

Currently implemented prettyprinters are: PrettyForm, TeXForm, Print
and DefaultPrint.

@
<<>>=
PrettyPrinter()
@ %def


%% %%% -------------------------------------------------------------
%% \section{Miscellaneous}
%% \label{sec:misc}



%% Note that the value returned by \yacas\ can be of different types:
%% @
%% <<print=T>>=
%% yacas(expression(Factor(x^2-1)),retclass='unquote')
%% yacas(expression(Factor(x^2-1)),retclass='character')
%% @ %def


\end{document}





%% It is important to note the difference between the \R\ name \code{x}
%% and the symbol \code{"x"} as illustrated below:
%% @
%% <<print=T>>=
%% x<- Sym("xs")
%% x
%% x+4
%% Eval(x+4, list(xs=5))
%% @ %def




%% The convention in the following is 1) that \sym\ objects match with
%% their names that they end with an 's', e.g.
%% @
%% <<>>=
%% xs <- Sym("xs")
%% @ %def




%% Now we can do:
%% @
%% <<eval=T>>=
%% Expand( (1 + x_)^4 )
%% @ %def




%% there is a \code{Expand()} function that calls the
%% \code{Expand} function in \yacas. T

%% However, it is NOT VALID to write
%% @
%% <<eval=F>>=
%% Expand( (1 + u)^4 )
%% @ %def
%% But - it is valid to wrap the above into an \R\ expression and call








%% @
%% <<>>=
%% x_ <- Sym("x")
%% y_ <- Sym("y")
%% Expand( (1 + x_)^4 )
%% Expand((1+x_-y_)^2, x_)
%% ## Expand((1+x_-y_)^2, {x_,y_})
%% @ %def






%% Expand((1+x-y)^2, x);
%% Expand((1+x-y)^2, {x,y})

%% \section{\R\ expressions,  \yacas\ expressions and \sym\ objects}
%% \label{sec:hood}

%% The \ryacas{} package works by sending ``commands'' to \yacas{} which
%% makes the calculations and returns the result to \R{}. This can be
%% done in various ways.








%% \subsection{\R\ expressions}

%% A call to \yacas\ may be in the form of an \R\ expression which
%% involves valid R calls, symbols or constants (though not all valid \R\
%% expressions are valid). For example:
%% @
%% <<print=T>>=
%% exp1<- yacas(expression(Factor(x^2-1)))
%% @ %def

%% The result \code{exp1} is not an expression in the \R\ sense but an
%% object of class \code{"yacas"}.
%% To evaluate the resulting expression numerically, we can do
%% @
%% <<>>=
%% Eval(exp1, list(x=4))
%% @ %def

%% \subsection{\yacas\ expressions}

%% Some commands are not proper \R\ expressions. For example,
%% typing
%% \begin{verbatim}
%%   yacas(expression(D(x)Sin(x)))
%% \end{verbatim}
%% produces an error.
%% For such cases we can make
%% a specification using the \yacas{} syntax:
%% @
%% <<>>=
%% yacas("D(x)Sin(x)")
%% @ %def


%% \subsection{\sym\ objects}

%% Probably the most elegant way of working with \yacas\ is by using
%% \sym\ objects.
%% A \sym\ object is a \yacas\ character string that has the "Sym" class.
%% One can combine \sym\ objects with other \sym\ objects as well as to
%% other \R\ objects using \code{+}, \code{-} and other similar \R\
%% operators.

%% The function \code{Sym(x)} coerces an object \code{x} to a \sym\ object by
%% first coercing it to character and then changing its class to "Sym":
%% @
%% <<print=T>>=
%% x<- Sym("x")
%% @ %def

%% Operations on \sym\ objects lead to new \sym\ objects:
%% @
%% <<print=T>>=
%% x+4
%% @ %def

%% One can apply \code{sin}, \code{cos}, \code{tan}, \code{deriv}, \code{Integrate}
%% and other provided functions to \sym\ objects. For example:
%% @
%% <<>>=
%% Integrate(sin(x), x)
%% @ %def
%% In this way the communication with \yacas\ is ``tacit''.

%% It is important to note the difference between the \R\ name \code{x}
%% and the symbol \code{"x"} as illustrated below:
%% @
%% <<print=T>>=
%% x<- Sym("xs")
%% x
%% x+4
%% Eval(x+4, list(xs=5))
%% @ %def

%% The convention in the following is 1) that \sym\ objects match with
%% their names that they end with an 's', e.g.
%% @
%% <<>>=
%% xs <- Sym("xs")
%% @ %def



%% \section{A sample session}
%% \label{sec:samplesession}





%% Algebraic calculations:
%% @
%% <<>>=
%% yacas(expression((10 + 2) * 5 + 7^7))
%% yacas(expression(1/14+5/21* (30- 1+ 1/2)))
%% @ %def

%% @
%% <<>>=
%% #(Sym(10) + Sym(2)) * Sym(5) + Sym(7) ^ Sym(7)
%% Sym("10 * 2") * 5 + Sym(7) ^ 7
%% #(Sym(10) + 2) * 5 + Sym(7) ^ 7
%% #Sym("(10+2)*5 + 7^7")
%% Sym("1/14 + 5/21 * (30 - 1+1/2)")
%% @ %def

%% Numerical evaluations:
%% @
%% <<>>=
%% yacas(expression(N(-12/2)))
%% @ %def
%% @
%% <<>>=
%% Sym("-12/2")
%% #Eval(Sym("-12/2"))
%% @ %def


%% Likewise:
%% @
%% <<>>=
%% as <- Sym("as")
%% zs <- Sym("zs")
%% Set(zs, cos(as))
%% zs + zs
%% @ %def


%% o clear a variable
%% binding execute \code{Clear()}:
%% @
%% <<>>=
%% yacas(expression(n))
%% yacas("Clear(n)")
%% yacas(expression(n))
%% @ %def

%% @
%% <<>>=
%% Set(ns, 1)
%% ns <- Sym("ns")
%% ns
%% Clear(ns)
%% ns
%% @ %def


%% \subsection{Symbolic and numerical evaluations, precision}

%% Evaluations are generally exact:
%% @
%% <<>>=
%% yacas("Exp(0)")
%% yacas("Exp(1)")
%% yacas("Sin(Pi/4)")
%% yacas("355/113")
%% @ %def

%% @
%% <<>>=
%% exp(Sym(0))
%% exp(Sym(1))
%% sin(Pi/4)
%% Sym("355/113")
%% @ %def

%%  To obtain a numerical evaluation
%% (approximation), the \code{N()} function can be used:
%% @
%% <<>>=
%% yacas("N(Exp(1))")
%% yacas("N(Sin(Pi/4))")
%% yacas("N(355/113)")
%% @ %def

%% @
%% <<>>=
%% N(exp(1))
%% N(sin(Pi/4))
%% N(355/113)
%% @ %def

%% @
%% <<>>=
%% yacas("N(355/133,20)")
%% @ %def

%% @
%% <<>>=
%% N("355/113",20)
%% @ %def


%% The command \code{Precision(n)}
%% can be used to specify that all floating point numbers should have a
%% fixed precision of n digits:
%% @
%% <<>>=
%% yacas("Precision(5)")
%% yacas("N(355/113)")
%% @ %def

%% @
%% <<>>=
%% Precision(5)
%% N("355/113")
%% @ %def


%% \subsection{Rational numbers}

%% Rational numbers will stay rational as long as the numerator and
%% denominator are integers:
%% @
%% <<>>=
%% yacas(expression(55/10))
%% @ %def

%% @
%% <<>>=
%% Sym("55 / 10")
%% @ %def


%% \subsection{Symbolic calculation}
%% \label{sec:symbolicCalculation}

%% Some exact manipulations :
%% @
%% <<>>=
%% yacas("1/14+5/21*(30-(1+1/2)*5^2)")
%% yacas("0+x")
%% yacas("x+1*y")
%% yacas("Sin(ArcSin(alpha))+Tan(ArcTan(beta))")
%% @ %def

%% @
%% <<>>=
%% Sym("1/14+5/21*(1*30-(1+1/2)*5^2)")
%% xs <- Sym("xs")
%% ys <- Sym("ys")
%% 0+xs
%% xs+1*ys
%% sin(asin(xs))+tan(atan(ys))
%% @ %def



%% \subsection{Analytical derivatives}

%% Analytical derivatives of functions can be evaluated with the
%% \code{D()} and \code{deriv()} functions:
%% @
%% <<>>=
%% yacas("D(x) Sin(x)")
%% @ %def

%% @
%% <<>>=
%% deriv(sin(xs), xs)
%% @ %def

%% These functions also accepts an argument specifying how often the
%% derivative has to be taken, e.g:
%% @
%% <<>>=
%% yacas("D(x,4)Sin(x)")
%% @ %def

%% @
%% <<>>=
%% deriv(sin(xs),xs,4)
%% @ %def

%% \subsection{Integration}

%% @
%% <<echo=F,results=hide>>=
%% yacas("Clear(a,b,A,B)")
%% @ %def

%% @
%% <<>>=
%% #yacas("Integrate(x,a,b)Sin(x)")
%% #yacas("Integrate(x,a,b)Ln(x)+x")
%% #yacas("Integrate(x)1/(x^2-1)")
%% yacas("Integrate(x)Sin(a*x)^2*Cos(b*x)")
%% @ %def


%% @
%% <<>>=
%% out <- yacas("Integrate(x)Sin(a*x)^2*Cos(b*x)")
%% @ %def



%% @
%% <<>>=
%% #Integrate(sin(x),x,a,b)
%% #Integrate(log(x),x,a,b)
%% #Integrate(1/(x^2-1),x)
%% a <- Sym("a")
%% b <- Sym("b")
%% Integrate(sin(a*x)^2*cos(b*x),x)
%% @ %def


%% \subsection{Variable substitution}

%% @
%% <<>>=
%% yacas("Subst(x,Cos(a))x+x")
%% @ %def

%% @
%% <<>>=
%% Subst(xs+xs,xs,cos(as))
%% @ %def


