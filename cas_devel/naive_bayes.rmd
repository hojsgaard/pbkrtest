---
title: "21 - Concentration and covariance matrix in an autoregressive model and in a dynamic linear model"
author: Mikkel Meyer Andersen and Søren Højsgaard
date: "`r date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{21 - Concentration and covariance matrix in an autoregressive model and in a dynamic linear model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
                      fig.width=5,
  collapse = TRUE,
  comment = "#>"
  )
```

```{r, message=FALSE, echo=FALSE}
library(caracas)
library(gRbase)
library(igraph)

myplot <- function(x, layout=layout.fruchterman.reingold(x), ...) {
  igraph::V(x)$size <- 60
  igraph::V(x)$label.cex <- 3
  plot(x, layout=layout, ...)
  return(invisible())
}
as_tex <- function(matr, zero_as_dot = FALSE) {

    ## if (zero_as_dot) {
        ## matr <- gsub("([^0-9])0([^0-9])", "\\1.\\2", matr)
    ## }
      
    printmrow <- function(x) {
        paste0(paste(x, collapse =" & "), "\\\\")
    }

    cn <- colnames(matr)
    if (!is.null(cn))
        cn <- paste0(paste(colnames(matr), collapse =" & "), "\\\\")
    beg <- "\\left[\\begin{matrix}" 
    end <- "\\end{matrix}\\right]"
    body <- apply(matr, 1, printmrow)
    paste0(c(beg, cn, body, end), collapse=" ")
}

```


```{r}
N <- 3
d <- dag(lapply(paste0("y", 1:N), c, "x"))
d |> myplot()
```

$$
V = L^{-1} (L^{-1})^\top; K = L^\top L
$$

```{r}
L <- dag2edge_matrix(d,2)
L
L1 <- as_sym(L)
L1inv <- solve(L1)
V <- L1inv %*% t(L1inv)
K <- t(L1) %*% L1
idx <- 1:nrow(L1)
solve_lower_triangular(L1)
## (V, K) er matching par
## (V %*% K) |> simplify()
```

$$
`r as_tex(L)`
$$

```{r, results="asis", echo=F}
cat(
  "\\begin{align} K &= ", tex(K), " \\\\ 
                  V &= ", tex(V), " \\end{align}", sep = "")
```


Marginalize: Marginalize onto $a$
```{r}
a <- 2:3
b <- setdiff(idx, a)

Vaa <- V[a,a,drop=F]
Kaa <- K[a,a,drop=F] - K[a,b,drop=F] %*% solve(K[b,b,drop=F], K[b,a,drop=F])
## (Vaa, Kaa) er matching par
## (Vaa %*% Kaa) |> simplify()
```

```{r, results="asis", echo=F}
cat(
  "\\begin{align} Kaa &= ", tex(Kaa), " \\\\ 
                  Vaa &= ", tex(Vaa), " \\end{align}", sep = "")
```

When can we marginalize directly on the $L$ matrix?

Suppose $L$ has the structure shown below, it is clear that 

```{r,echo=F}
L <- matrix(c("I","0","B", "I"), nrow=2, byrow=T)
Li <- matrix(c("I","0","-B", "I"), nrow=2, byrow=T)
```

$$
L= `r as_tex(L)` L^{-1}=`r as_tex(Li)`
$$



```{r}
a <- 1:3
b <- setdiff(idx, a)

L1aa   <- L1[a,a]
L1aa.i <- solve(L1aa)
Vaa2   <- L1aa.i %*% t(L1aa.i)
Vaa    <- V[a,a,drop=F]
```

```{r}
a <- 2:3
b <- setdiff(idx, a)

L1aa <- L1[a,a]
L1aa.i <- solve(L1aa)
Vaa2 <- L1aa.i %*% t(L1aa.i)
Vaa <- V[a,a,drop=F]
```

```{r}
d2 <- dag(~c|a:b+d:c)
a <- c("a","b","c")
ag <- ancestralGraph(a, d2)
setequal(nodes(ag), a)

ch <-dag2edge_matrix(d2)
ch
edge_matrix2dag(ch) |> myplot()
```
$$
`r as_tex(ch)`
$$


## Regression 

Regress $y_A$ on $y_B$. Two forms for regression coefficients

$$
\beta = V_{AB}(V_{BB})^{-1} = -(K_{AA})^{-1} K_{AB}
$$

Likewise, two forms for conditional variance

$$
V(y_A|y_B)= V_{AA}-V_{AB}(V_{BB})^{-1}V_{BA}=V_{AA}-\beta V_{BA}
$$

$$
V(y_A|y_B)= (K_{AA})^{-1}
$$


```{r, eval=T}
do_sim <- function(x){caracas::simplify(x)}
## Regression, af 1 på 2,3,... to former
A <- 1
B <- setdiff(1:nrow(V), A)
(V[A, B, drop=F] %*% solve(V[B, B])) |> do_sim()
-solve(K[A, A, drop=FALSE], K[A, B, drop=FALSE])

V.A_B <- V[A, A, drop=FALSE] - V[A, B, drop=FALSE] %*% solve(V[B, B, drop=FALSE], V[B, A, drop=FALSE])
V.A_B |> do_sim()

solve(K[A, A, drop=F])

## Regression, af 1 på 2,3, to former
(Vaa[1, -1, drop=F] %*% solve(Vaa[-1, -1, drop=FALSE])) |> do_sim()
solve(Kaa[1, 1, drop=FALSE], Kaa[1, -1, drop=FALSE])
```













<!-- ```{r} -->
<!-- cc <- function (...)  -->
<!-- { -->
<!--     dots <- match.call(expand.dots = FALSE)$... -->
<!--     nms <- lapply(seq_along(dots), function(i) { -->
<!--         y <- if (is.symbol(dots[[i]])) { -->
<!--             deparse(dots[[i]]) -->
<!--         } -->
<!--         else { -->
<!--             dots[[i]] -->
<!--         } -->
<!--         return(y) -->
<!--     }) -->
<!--     unlist(nms, recursive = TRUE) -->
<!-- } -->

<!-- cc("a","b","c", list(1,2,3))[[4]] -->
<!-- c("a","b","c", list(1,2,3))     -->
<!-- ``` -->
