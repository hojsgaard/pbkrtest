#' @title Likelihood Ratio Test Between Nested Models
#'
#' @description
#' Performs a likelihood ratio test (LRT) between two nested models. Supports
#' models of class `lm`, `lmerMod`, `glmerMod`, `lme`, and `gls`.
#'
#' @param fit1 A model object representing the more complex (full) model.
#' @param fit0 A model object representing the simpler (nested) model.
#'
#' @return A named numeric vector with:
#' \describe{
#'   \item{tobs}{Test statistic (twice the difference in log-likelihoods).}
#'   \item{df}{Degrees of freedom (difference in number of parameters).}
#'   \item{p.value}{P-value from the chi-squared distribution.}
#' }
#'
#' @examples
#' ## lm
#' fit1 <- lm(mpg ~ wt + hp, data = mtcars)
#' fit0 <- lm(mpg ~ wt, data = mtcars)
#' getLRT(fit1, fit0)
#'
#' ## lmerMod
#' if (requireNamespace("lme4", quietly = TRUE)) {
#'   library(lme4)
#'   fit1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy, REML = FALSE)
#'   fit0 <- lmer(Reaction ~ 1 + (Days | Subject), sleepstudy, REML = FALSE)
#'   getLRT(fit1, fit0)
#' }
#'
#' ## glmerMod
#' if (requireNamespace("lme4", quietly = TRUE)) {
#'   library(lme4)
#'   data(cbpp)
#'   fit1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
#'                 data = cbpp, family = binomial)
#'   fit0 <- glmer(cbind(incidence, size - incidence) ~ 1 + (1 | herd),
#'                 data = cbpp, family = binomial)
#'   getLRT(fit1, fit0)
#' }
#'
#' ## lme
#' if (requireNamespace("nlme", quietly = TRUE)) {
#'   library(nlme)
#'   fit1 <- lme(distance ~ age + Sex, random = ~1 | Subject,
#'               data = Orthodont, method = "ML")
#'   fit0 <- lme(distance ~ age, random = ~1 | Subject,
#'               data = Orthodont, method = "ML")
#'   getLRT(fit1, fit0)
#' }
#'
#' ## gls
#' if (requireNamespace("nlme", quietly = TRUE)) {
#'   library(nlme)
#'   fit1 <- gls(mpg ~ wt + hp, data = mtcars, method = "ML")
#'   fit0 <- gls(mpg ~ wt, data = mtcars, method = "ML")
#'   getLRT(fit1, fit0)
#' }
#'
#' @export
getLRT <- function(fit1, fit0) {
  UseMethod("getLRT")
}

#' @export
getLRT.lm <- function(fit1, fit0) {
  logL1 <- logLik(fit1)
  logL0 <- logLik(fit0)
  tobs  <- 2 * (logL1 - logL0)
  df    <- attr(logL1, "df") - attr(logL0, "df")
  pval  <- 1 - pchisq(tobs, df)
  c(tobs = tobs, df = df, p.value = pval)
}

#' @export
getLRT.lmerMod <- function(fit1, fit0) {
  logL1 <- logLik(update(fit1, REML = FALSE))
  logL0 <- logLik(update(fit0, REML = FALSE))
  tobs  <- 2 * (logL1 - logL0)
  df    <- attr(logL1, "df") - attr(logL0, "df")
  pval  <- 1 - pchisq(tobs, df)
  c(tobs = tobs, df = df, p.value = pval)
}

#' @export
getLRT.glmerMod <- function(fit1, fit0) {
  logL1 <- logLik(update(fit1))
  logL0 <- logLik(update(fit0))
  tobs  <- 2 * (logL1 - logL0)
  df    <- attr(logL1, "df") - attr(logL0, "df")
  pval  <- 1 - pchisq(tobs, df)
  c(tobs = tobs, df = df, p.value = pval)
}

#' @export
getLRT.lme <- function(fit1, fit0) {
  logL1 <- logLik(update(fit1, method = "ML"))
  logL0 <- logLik(update(fit0, method = "ML"))
  tobs  <- 2 * (logL1 - logL0)
  df    <- attr(logL1, "df") - attr(logL0, "df")
  pval  <- 1 - pchisq(tobs, df)
  c(tobs = tobs, df = df, p.value = pval)
}

#' @export
getLRT.gls <- function(fit1, fit0) {
  logL1 <- logLik(update(fit1, method = "ML"))
  logL0 <- logLik(update(fit0, method = "ML"))
  tobs  <- 2 * (logL1 - logL0)
  df    <- attr(logL1, "df") - attr(logL0, "df")
  pval  <- 1 - pchisq(tobs, df)
  c(tobs = tobs, df = df, p.value = pval)
}


#' @title Extract (or "get") components from a \code{KRmodcomp} or
#'     \code{SATmodcomp} object.
#'
#' @description Extract (or "get") components from a \code{KRmodcomp}
#'     or \code{SATmodcomp} object. In particular, get denominator
#'     degrees of freedom.
#' 
#' @name get_modcomp
#' 
#' @param object A \code{KRmodcomp} object, which is the result of the
#'     \code{KRmodcomp} function
#' @param name The available slots. If \code{name} is missing or \code{NULL}
#'     then everything is returned.
#' @author Søren Højsgaard \email{sorenh@@math.aau.dk}
#' @seealso \code{\link{KRmodcomp}}, \code{\link{PBmodcomp}},
#'     \code{\link{vcovAdj}}
#' @references Ulrich Halekoh, Søren Højsgaard (2014)., A Kenward-Roger
#'     Approximation and Parametric Bootstrap Methods for Tests in Linear Mixed
#'     Models - The R Package pbkrtest., Journal of Statistical Software,
#'     58(10), 1-30., \url{https://www.jstatsoft.org/v59/i09/}
#' @keywords utilities
#' @examples
#'
#' (fm0 <- lmer(Reaction ~ (Days|Subject), sleepstudy))
#' (fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
#' (fm2 <- lmer(Reaction ~ Days + I(Days^2) + (Days|Subject), sleepstudy))
#'
#' x10 <- KRmodcomp(fm1, fm0)
#' getKR(x10, "ddf")
#'
#' KRmodcomp(fm1, fm0) |> getKR("ddf")
#' KRmodcomp(fm2, fm0) |> getKR("ddf")
#' KRmodcomp(fm2, fm1) |> getKR("ddf")
#'
#' ## For comparison:
#' 
#' SATmodcomp(fm1, fm0) |> getSAT("ddf")
#' SATmodcomp(fm2, fm0) |> getSAT("ddf")
#' SATmodcomp(fm2, fm1) |> getSAT("ddf")
#'
#' @export
#' @rdname get_modcomp
getKR <- function (object, name = c("ndf", "ddf", "Fstat", "p.value", "F.scaling", "FstatU", "p.valueU", "aux")) 
{	
  stopifnot(is(object, "KRmodcomp"))
  if (missing(name) || is.null(name)){
    return(object$stats)
  } else {
    stopifnot(length(name <- as.character(name)) == 1)
    name <- match.arg(name)
    object$stats[[name]]
  }
}


#' @export
#' @rdname get_modcomp
getSAT <- function (object, name = c("ndf", "ddf", "Fstat", "p.value")) 
{	
  stopifnot(is(object, "SATmodcomp"))
  if (missing(name) || is.null(name)){
    return(object$test) ## FIXME Should be stats
  } else {
    stopifnot(length(name <- as.character(name)) == 1)
    name <- match.arg(name)
    object$test[[name]] ## FIXME Should be stats
  }
}


## '
## ' \dontrun{
## ' p <- PBrefdist(fm1, fm0, seed=123, nsim=50, cl=1)
## ' e <- mean(p)
## ' e
## ' -2*e/(1-e)
## ' 
## ' x <- PBmodcomp(fm1, fm0, nsim=50, seed=123, cl=1)
## ' summary(x)$test$ddf[5]
## '
## ' x <- PBmodcomp(fm2, fm0, nsim=50, cl=2)
## ' summary(x)$test$ddf[5]
## '
## ' x <- PBmodcomp(fm2, fm1, nsim=50, cl=2)
## ' summary(x)$test$ddf[5]
## ' }
## ' 



