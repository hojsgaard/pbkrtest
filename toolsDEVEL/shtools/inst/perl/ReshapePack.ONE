%%
%% AUTOMATICALLY GENERATED FILE - DO NOT EDIT MANUALLY
%% File origin : ReshapePack.Snw 
%%
\documentclass[a4paper,11pt]{article}

\usepackage{amsmath,alltt}

%\newcommand{\t}{\mathrm{time}}

\title{Reshape Package in R: melt.data.frame( )}
\author{Ana Paola S\'anchez de Schubert}
\date{November 15th, 2006}


\begin{document}
\maketitle

\section{The Reshape Package}\label{sec:one}
It is a package for estructuring and agregating data. To reshape the
data means to rearrange it but preserving the original information.
However, \verb+aggregation+ differs from \verb+reshaping+, because the
first one reduces and rearrange the data into a more convinient form,
reducing many cells of the original data set to one cell in the new
dataset.

\verb+Reshape Package+ performs melting and casting operations through
two functions: \verb+''melt''+ and \verb+''cast''+, it requires less
input arguments than the \verb+Reshape()+ function in R.

Considering that the defining feature of longitudinal data is that the
measurements of the same individual are taken repeatedly trough time,
the \verb+Reshape Package+ is useful to change its format from
\verb+wide+ to \verb+long+.

For the reshaping procedure, the variables of the longitudinal data
can be divides into 2 groups:

\begin{enumerate}

\item \verb+Identifier+ or \verb+id variables+: identify the unit
  where the measurements take place.

\item \verb+ Measured variables+: represent what is measured on the
  unit.

\end{enumerate}



\section{Melt() function in R}\label{sec:two}
 
\subsection{Description}\label{subsec:one}
The function melts a data frame into a form suitable for easy
casting.\footnote{$\mathtt{\backslash R\text{-}2.4.0\backslash
    library\backslash reshape\backslash html\backslash
    melt\text{-}24.html}$} It is used in Longitudinal Data for
changing the format of the data from wide to long.

Consider the following dataset with two ID variables, \verb+subject+ and \verb+time+:

<<echo=false>>=
d1<-data.frame(subject=c("John Smith", "Mary Smith"),time=c(1,1),age=c(33,NA),weight=c(90,NA),height=c(2,2))
d1
@ 

Melting the data set, we get a new one of the form, 

<<echo=false>>=
d2<-data.frame(subject=c("John Smith","John Smith", "John Smith","Mary Smith"),time=c(1,1,1,1),variable=c("age","weight","height","height"),value=c(33,90,2,2))
d2
@ 

which each row represents one observation of one variable. It produces automatically a new  \verb+ID+ variable \verb+''variable''+ and the value of each observation is stored in \verb+''value''+.

\subsection{Syntaxis of melt.data.frame() function}\label{subsec:two}

Assuming that a data frame is provided, we use the \verb+melt()+ function as:

\bigskip
\verb+melt.data.frame( data, id.var, measure.var, variable_name = ''variable'', preserve.na = TRUE, ...)+
\bigskip

or simply use \verb+melt(...)+. The arguments of the function are,

\begin{enumerate}

\item \verb+data+ : Data set to melt. 
\item \verb+id.var+ : Identifying variables.
\item \verb+measure.var+ : Measured variables. 
\item \verb+variable_name+ : Name of the variable that will store the names of the original variables 
\item \verb+preserve.na+ : for the NAs to be preserved or dropped from the data set.

\end{enumerate}

The \verb+Identifier (categorical)+ and \verb+measured (continuous)+ variables need to be communicated to the \verb+melt+ function. If we do not specify the \verb+ID+ variables, \verb+melt()+ will take all the \verb+factor+ or \verb+integer+ columns as \verb+ID+ variables. If we do not provide the \verb+measured+ variables, \verb+melt()+ will assume all the continuous columns as \verb+measured+ variables.
Therefore, all the following statements give the same data sets:

\begin{itemize}
\item \verb+melt(smiths, id=c("subject","time"),measured=c("age","weight","height"))+
\item \verb+melt(smiths, id=c("subject","time"))+
\item \verb+melt(smiths, id=1:2)+
\item \verb+melt(smiths, measured=c("age","weight","height"))+
\item \verb+melt(smiths)+
\end{itemize}


\subsection{From wide to long format}\label{subsec:three}
Consider the following dataset for 5 pigs measuring the length
(seconds) of eating periods every 30 minutes, with two ID variables:
\verb+time+ and \verb+dayhour+. Where \verb+time+ assigns a number to
each observation and \verb+dayhour+ shows the daytime of the period.
The data is shown in the \verb+wide+ format,


<<echo=false, results=hide>>= 
############################### PIGS DATA #################################
# install.packages("reshape")
library(reshape)
# using "melt", from "reshape" package
###########################################################################

#######################  DATA EVERY 30 MIN ################################# 
#EatPig30 <- read.csv(file="C:/Dokumente\ und\ Einstellungen/Ana\ Paola/Desktop/Tjele/2006-EatingPig/data/minute30.csv",header=T)
EatPig30 <- read.csv(file="data/minute30.csv",header=T)
length(EatPig30$minute30)
attributes(EatPig30)
# we drop the totals
EatPig30ind <- EatPig30[,c(1:7,10:41)]
EatPig30ind$time <- rep(1:194)
dim(EatPig30ind)
date <- EatPig30ind$minute30 
# To convert 28FEB05:08:00:00 to "2005-02-28 08:00:00"
# as.POSIXlt:Functions to manipulate objects of classes "POSIXlt" and "POSIXct" representing calendar dates and times.
# Since we have 28FEB05:08:00:00, we use strptime:Functions to convert between character representations and objects of classes "POSIXlt" and "POSIXct" representing calendar dates and times. 
date1 <- as.POSIXlt(strptime(date, format="%d%b%y:%H:%M:%S"))
# unclass: separates the "2005-02-28 08:00:00" on : sec, min, hour, mday, month, year, wday, yday 
# Add the hour with dayhour to the data. First day from 8 to 23hours, the 2 and 3 day from 0 to 23 hours, the 4 day from 0 to 10 hours: ANALYZE THIS!!!!!!
hour <- unclass(date1)$hour
# Since we have half hours, the hours are repeated then we add the minutes, but as .5
min <- (unclass(date1)$min)/60
dayhour <- hour+min
EatPig30ind$dayhour<-dayhour
# Data for the Sec.eat
TimePig30ind <- EatPig30ind[1:3,c(8:12,40:41)]
dim(TimePig30ind)

@ 

<<echo=false >>=
TimePig30ind
@ 

To present the data in the \verb+long+ format, we use the \verb+melt+ function taking the \verb+time+ and \verb+dayhour+ as the identifier variables and the rest as measure variables:

<<  >>=
########## Reshaping  the data with the variable for the eating time:############
# drop  NA, measure var are the values: eating time (length)
TimePig30ind0 <-  melt(TimePig30ind, id=6:7,measure.var=1:5)
@ 

<<echo=false >>=
TimePig30ind0
@ 

The variable \verb+''value''+ has been created and it stores the values of \verb+''Sec.eat''+.
In order to change the name of \verb+''variable''+, which identifies the subject, we add \verb+variable_name=...+

<<  >>=
########## Reshaping  the data with the variable for the eating time:############
# drop  NA, measure var are the values: eating time (length)
TimePig30ind1 <-  melt(TimePig30ind, id=6:7,measure.var=1:5,variable_name ="ID")

@ 

<<echo=false>>=
TimePig30ind1
@ 


To drop the mising data, we add \verb+preserve.na=FALSE+, and to change the name of the variable \verb+value+ to \verb+''Sec.eat''+, we use \verb+names()+ ,
<<  >>=
########## Reshaping  the data with the variable for the eating time:############
# drop  NA, measure var are the values: eating time (length)
TimePig30ind2 <-  melt(TimePig30ind, id=6:7,measure.var=1:5,variable_name ="ID",preserve.na=FALSE)
names(TimePig30ind2) <- c( "time","dayhour","ID","Sec.eat")
@ 


<<echo=false >>=
TimePig30ind2
@ 


\section*{Bibliography}\label{sec:three}

\begin{enumerate}
\item Hadley Wickham. \verb+ Reshaping data with the reshape package+. \linebreak \verb+(http://had.co.nz/reshape)+
\item Hadley Wickham. \verb+ melt {reshape}+ \\\verb+ (R-2.4.0\library\reshape\html\melt-24.html) +
\end{enumerate}

\end{document}
